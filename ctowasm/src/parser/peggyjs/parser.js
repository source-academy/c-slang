// @generated by Peggy 4.0.2.
//
// https://peggyjs.org/

"use strict";


function peg$subclass(child, parent) {
  function C() { this.constructor = child; }
  C.prototype = parent.prototype;
  child.prototype = new C();
}

function peg$SyntaxError(message, expected, found, location) {
  var self = Error.call(this, message);
  // istanbul ignore next Check is a necessary evil to support older environments
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(self, peg$SyntaxError.prototype);
  }
  self.expected = expected;
  self.found = found;
  self.location = location;
  self.name = "SyntaxError";
  return self;
}

peg$subclass(peg$SyntaxError, Error);

function peg$padEnd(str, targetLength, padString) {
  padString = padString || " ";
  if (str.length > targetLength) { return str; }
  targetLength -= str.length;
  padString += padString.repeat(targetLength);
  return str + padString.slice(0, targetLength);
}

peg$SyntaxError.prototype.format = function(sources) {
  var str = "Error: " + this.message;
  if (this.location) {
    var src = null;
    var k;
    for (k = 0; k < sources.length; k++) {
      if (sources[k].source === this.location.source) {
        src = sources[k].text.split(/\r\n|\n|\r/g);
        break;
      }
    }
    var s = this.location.start;
    var offset_s = (this.location.source && (typeof this.location.source.offset === "function"))
      ? this.location.source.offset(s)
      : s;
    var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
    if (src) {
      var e = this.location.end;
      var filler = peg$padEnd("", offset_s.line.toString().length, ' ');
      var line = src[s.line - 1];
      var last = s.line === e.line ? e.column : line.length + 1;
      var hatLen = (last - s.column) || 1;
      str += "\n --> " + loc + "\n"
          + filler + " |\n"
          + offset_s.line + " | " + line + "\n"
          + filler + " | " + peg$padEnd("", s.column - 1, ' ')
          + peg$padEnd("", hatLen, "^");
    } else {
      str += "\n at " + loc;
    }
  }
  return str;
};

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function(expectation) {
      return "\"" + literalEscape(expectation.text) + "\"";
    },

    class: function(expectation) {
      var escapedParts = expectation.parts.map(function(part) {
        return Array.isArray(part)
          ? classEscape(part[0]) + "-" + classEscape(part[1])
          : classEscape(part);
      });

      return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
    },

    any: function() {
      return "any character";
    },

    end: function() {
      return "end of input";
    },

    other: function(expectation) {
      return expectation.description;
    }
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, "\\\\")
      .replace(/"/g,  "\\\"")
      .replace(/\0/g, "\\0")
      .replace(/\t/g, "\\t")
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/[\x00-\x0F]/g,          function(ch) { return "\\x0" + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return "\\x"  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, "\\\\")
      .replace(/\]/g, "\\]")
      .replace(/\^/g, "\\^")
      .replace(/-/g,  "\\-")
      .replace(/\0/g, "\\0")
      .replace(/\t/g, "\\t")
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/[\x00-\x0F]/g,          function(ch) { return "\\x0" + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return "\\x"  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = expected.map(describeExpectation);
    var i, j;

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== undefined ? options : {};

  var peg$FAILED = {};
  var peg$source = options.grammarSource;

  var peg$startRuleFunctions = { program: peg$parseprogram };
  var peg$startRuleFunction = peg$parseprogram;

  var peg$c0 = " ";
  var peg$c1 = "{";
  var peg$c2 = "}";
  var peg$c3 = "return";
  var peg$c4 = ";";
  var peg$c5 = "break";
  var peg$c6 = "continue";
  var peg$c7 = "do";
  var peg$c8 = "while";
  var peg$c9 = "(";
  var peg$c10 = ")";
  var peg$c11 = "for";
  var peg$c12 = "if";
  var peg$c13 = "else";
  var peg$c14 = "switch";
  var peg$c15 = "default";
  var peg$c16 = ":";
  var peg$c17 = "case";
  var peg$c18 = "const";
  var peg$c19 = "auto";
  var peg$c20 = "static";
  var peg$c21 = "typedef";
  var peg$c22 = "void";
  var peg$c23 = "char";
  var peg$c24 = "int";
  var peg$c25 = "float";
  var peg$c26 = "double";
  var peg$c27 = "long";
  var peg$c28 = "short";
  var peg$c29 = "signed";
  var peg$c30 = "unsigned";
  var peg$c31 = ",";
  var peg$c32 = "=";
  var peg$c33 = "*";
  var peg$c34 = "[";
  var peg$c35 = "]";
  var peg$c36 = "struct";
  var peg$c37 = "enum";
  var peg$c38 = "+=";
  var peg$c39 = "-=";
  var peg$c40 = "*=";
  var peg$c41 = "/=";
  var peg$c42 = "%=";
  var peg$c43 = "<<=";
  var peg$c44 = ">>=";
  var peg$c45 = "&=";
  var peg$c46 = "^=";
  var peg$c47 = "|=";
  var peg$c48 = "?";
  var peg$c49 = "||";
  var peg$c50 = "&&";
  var peg$c51 = "|";
  var peg$c52 = "^";
  var peg$c53 = "&";
  var peg$c54 = "!=";
  var peg$c55 = "==";
  var peg$c56 = "<=";
  var peg$c57 = ">=";
  var peg$c58 = "<<";
  var peg$c59 = ">>";
  var peg$c60 = "++";
  var peg$c61 = "--";
  var peg$c62 = "sizeof";
  var peg$c63 = ".";
  var peg$c64 = "->";
  var peg$c65 = "@";
  var peg$c66 = "#include <";
  var peg$c67 = ">";
  var peg$c68 = "_Static_assert";
  var peg$c69 = "_Thread_local";
  var peg$c70 = "_Imaginary";
  var peg$c71 = "_Noreturn";
  var peg$c72 = "register";
  var peg$c73 = "restrict";
  var peg$c74 = "volatile";
  var peg$c75 = "_Alignas";
  var peg$c76 = "_Alignof";
  var peg$c77 = "_Complex";
  var peg$c78 = "_Generic";
  var peg$c79 = "_Atomic";
  var peg$c80 = "extern";
  var peg$c81 = "inline";
  var peg$c82 = "union";
  var peg$c83 = "_Bool";
  var peg$c84 = "goto";
  var peg$c85 = "0";
  var peg$c86 = "0x";
  var peg$c87 = "0X";
  var peg$c88 = "ll";
  var peg$c89 = "LL";
  var peg$c90 = "'";
  var peg$c91 = "\\'";
  var peg$c92 = "\\\"";
  var peg$c93 = "\\?";
  var peg$c94 = "\\\\";
  var peg$c95 = "\\a";
  var peg$c96 = "\\b";
  var peg$c97 = "\\f";
  var peg$c98 = "\\r";
  var peg$c99 = "\\n";
  var peg$c100 = "\\t";
  var peg$c101 = "\\v";
  var peg$c102 = "\\";
  var peg$c103 = "\\x";
  var peg$c104 = "\"";
  var peg$c105 = "%:%:";
  var peg$c106 = "...";
  var peg$c107 = "##";
  var peg$c108 = "%:";
  var peg$c109 = "<:";
  var peg$c110 = ":>";
  var peg$c111 = "<%";
  var peg$c112 = "%>";

  var peg$r0 = /^[<>]/;
  var peg$r1 = /^[+\-]/;
  var peg$r2 = /^[%*\/]/;
  var peg$r3 = /^[!+\-~]/;
  var peg$r4 = /^[a-z0-9!'"#%&()*+,-.\/: ;<=>?[\]\^_{|}~\t\v\f]/i;
  var peg$r5 = /^[a-z_]/i;
  var peg$r6 = /^[a-z0-9_]/i;
  var peg$r7 = /^[1-9]/;
  var peg$r8 = /^[0-9]/;
  var peg$r9 = /^[0-7]/;
  var peg$r10 = /^[0-9A-F]/i;
  var peg$r11 = /^[Uu]/;
  var peg$r12 = /^[Ll]/;
  var peg$r13 = /^[Ee]/;
  var peg$r14 = /^[fl]/i;
  var peg$r15 = /^[a-z0-9!"#%&()*+,-.\/: ;<=>?[\]\^_{|}~\t\v\f]/i;
  var peg$r16 = /^[a-z0-9!'#%&()*+,-.\/: ;<=>?[\]\^_{|}~\t\v\f]/i;
  var peg$r17 = /^[!#%-&(-\/:-?[\]-\^{-~]/;

  var peg$e0 = peg$otherExpectation("token separator");
  var peg$e1 = peg$literalExpectation(" ", false);
  var peg$e2 = peg$otherExpectation("block");
  var peg$e3 = peg$literalExpectation("{", false);
  var peg$e4 = peg$literalExpectation("}", false);
  var peg$e5 = peg$literalExpectation("return", false);
  var peg$e6 = peg$literalExpectation(";", false);
  var peg$e7 = peg$literalExpectation("break", false);
  var peg$e8 = peg$literalExpectation("continue", false);
  var peg$e9 = peg$literalExpectation("do", false);
  var peg$e10 = peg$literalExpectation("while", false);
  var peg$e11 = peg$literalExpectation("(", false);
  var peg$e12 = peg$literalExpectation(")", false);
  var peg$e13 = peg$literalExpectation("for", false);
  var peg$e14 = peg$literalExpectation("if", false);
  var peg$e15 = peg$literalExpectation("else", false);
  var peg$e16 = peg$literalExpectation("switch", false);
  var peg$e17 = peg$literalExpectation("default", false);
  var peg$e18 = peg$literalExpectation(":", false);
  var peg$e19 = peg$literalExpectation("case", false);
  var peg$e20 = peg$literalExpectation("const", false);
  var peg$e21 = peg$literalExpectation("auto", false);
  var peg$e22 = peg$literalExpectation("static", false);
  var peg$e23 = peg$literalExpectation("typedef", false);
  var peg$e24 = peg$literalExpectation("void", false);
  var peg$e25 = peg$literalExpectation("char", false);
  var peg$e26 = peg$literalExpectation("int", false);
  var peg$e27 = peg$literalExpectation("float", false);
  var peg$e28 = peg$literalExpectation("double", false);
  var peg$e29 = peg$literalExpectation("long", false);
  var peg$e30 = peg$literalExpectation("short", false);
  var peg$e31 = peg$literalExpectation("signed", false);
  var peg$e32 = peg$literalExpectation("unsigned", false);
  var peg$e33 = peg$literalExpectation(",", false);
  var peg$e34 = peg$literalExpectation("=", false);
  var peg$e35 = peg$literalExpectation("*", false);
  var peg$e36 = peg$literalExpectation("[", false);
  var peg$e37 = peg$literalExpectation("]", false);
  var peg$e38 = peg$literalExpectation("struct", false);
  var peg$e39 = peg$literalExpectation("enum", false);
  var peg$e40 = peg$literalExpectation("+=", false);
  var peg$e41 = peg$literalExpectation("-=", false);
  var peg$e42 = peg$literalExpectation("*=", false);
  var peg$e43 = peg$literalExpectation("/=", false);
  var peg$e44 = peg$literalExpectation("%=", false);
  var peg$e45 = peg$literalExpectation("<<=", false);
  var peg$e46 = peg$literalExpectation(">>=", false);
  var peg$e47 = peg$literalExpectation("&=", false);
  var peg$e48 = peg$literalExpectation("^=", false);
  var peg$e49 = peg$literalExpectation("|=", false);
  var peg$e50 = peg$literalExpectation("?", false);
  var peg$e51 = peg$literalExpectation("||", false);
  var peg$e52 = peg$literalExpectation("&&", false);
  var peg$e53 = peg$literalExpectation("|", false);
  var peg$e54 = peg$literalExpectation("^", false);
  var peg$e55 = peg$literalExpectation("&", false);
  var peg$e56 = peg$literalExpectation("!=", false);
  var peg$e57 = peg$literalExpectation("==", false);
  var peg$e58 = peg$literalExpectation("<=", false);
  var peg$e59 = peg$literalExpectation(">=", false);
  var peg$e60 = peg$classExpectation(["<", ">"], false, false);
  var peg$e61 = peg$literalExpectation("<<", false);
  var peg$e62 = peg$literalExpectation(">>", false);
  var peg$e63 = peg$classExpectation(["+", "-"], false, false);
  var peg$e64 = peg$classExpectation(["%", "*", "/"], false, false);
  var peg$e65 = peg$literalExpectation("++", false);
  var peg$e66 = peg$literalExpectation("--", false);
  var peg$e67 = peg$classExpectation(["!", "+", "-", "~"], false, false);
  var peg$e68 = peg$literalExpectation("sizeof", false);
  var peg$e69 = peg$literalExpectation(".", false);
  var peg$e70 = peg$literalExpectation("->", false);
  var peg$e71 = peg$classExpectation([["a", "z"], ["0", "9"], "!", "'", "\"", "#", "%", "&", "(", ")", "*", "+", [",", "."], "/", ":", " ", ";", "<", "=", ">", "?", "[", "]", "^", "_", "{", "|", "}", "~", "\t", "\v", "\f"], false, true);
  var peg$e72 = peg$literalExpectation("@", false);
  var peg$e73 = peg$literalExpectation("#include <", false);
  var peg$e74 = peg$literalExpectation(">", false);
  var peg$e75 = peg$literalExpectation("_Static_assert", false);
  var peg$e76 = peg$literalExpectation("_Thread_local", false);
  var peg$e77 = peg$literalExpectation("_Imaginary", false);
  var peg$e78 = peg$literalExpectation("_Noreturn", false);
  var peg$e79 = peg$literalExpectation("register", false);
  var peg$e80 = peg$literalExpectation("restrict", false);
  var peg$e81 = peg$literalExpectation("volatile", false);
  var peg$e82 = peg$literalExpectation("_Alignas", false);
  var peg$e83 = peg$literalExpectation("_Alignof", false);
  var peg$e84 = peg$literalExpectation("_Complex", false);
  var peg$e85 = peg$literalExpectation("_Generic", false);
  var peg$e86 = peg$literalExpectation("_Atomic", false);
  var peg$e87 = peg$literalExpectation("extern", false);
  var peg$e88 = peg$literalExpectation("inline", false);
  var peg$e89 = peg$literalExpectation("union", false);
  var peg$e90 = peg$literalExpectation("_Bool", false);
  var peg$e91 = peg$literalExpectation("goto", false);
  var peg$e92 = peg$classExpectation([["a", "z"], "_"], false, true);
  var peg$e93 = peg$classExpectation([["a", "z"], ["0", "9"], "_"], false, true);
  var peg$e94 = peg$literalExpectation("0", false);
  var peg$e95 = peg$classExpectation([["1", "9"]], false, false);
  var peg$e96 = peg$classExpectation([["0", "9"]], false, false);
  var peg$e97 = peg$classExpectation([["0", "7"]], false, false);
  var peg$e98 = peg$literalExpectation("0x", false);
  var peg$e99 = peg$literalExpectation("0X", false);
  var peg$e100 = peg$classExpectation([["0", "9"], ["A", "F"]], false, true);
  var peg$e101 = peg$classExpectation(["U", "u"], false, false);
  var peg$e102 = peg$classExpectation(["L", "l"], false, false);
  var peg$e103 = peg$literalExpectation("ll", false);
  var peg$e104 = peg$literalExpectation("LL", false);
  var peg$e105 = peg$classExpectation(["E", "e"], false, false);
  var peg$e106 = peg$classExpectation(["f", "l"], false, true);
  var peg$e107 = peg$literalExpectation("'", false);
  var peg$e108 = peg$classExpectation([["a", "z"], ["0", "9"], "!", "\"", "#", "%", "&", "(", ")", "*", "+", [",", "."], "/", ":", " ", ";", "<", "=", ">", "?", "[", "]", "^", "_", "{", "|", "}", "~", "\t", "\v", "\f"], false, true);
  var peg$e109 = peg$literalExpectation("\\'", false);
  var peg$e110 = peg$literalExpectation("\\\"", false);
  var peg$e111 = peg$literalExpectation("\\?", false);
  var peg$e112 = peg$literalExpectation("\\\\", false);
  var peg$e113 = peg$literalExpectation("\\a", false);
  var peg$e114 = peg$literalExpectation("\\b", false);
  var peg$e115 = peg$literalExpectation("\\f", false);
  var peg$e116 = peg$literalExpectation("\\r", false);
  var peg$e117 = peg$literalExpectation("\\n", false);
  var peg$e118 = peg$literalExpectation("\\t", false);
  var peg$e119 = peg$literalExpectation("\\v", false);
  var peg$e120 = peg$literalExpectation("\\", false);
  var peg$e121 = peg$literalExpectation("\\x", false);
  var peg$e122 = peg$literalExpectation("\"", false);
  var peg$e123 = peg$classExpectation([["a", "z"], ["0", "9"], "!", "'", "#", "%", "&", "(", ")", "*", "+", [",", "."], "/", ":", " ", ";", "<", "=", ">", "?", "[", "]", "^", "_", "{", "|", "}", "~", "\t", "\v", "\f"], false, true);
  var peg$e124 = peg$literalExpectation("%:%:", false);
  var peg$e125 = peg$literalExpectation("...", false);
  var peg$e126 = peg$literalExpectation("##", false);
  var peg$e127 = peg$literalExpectation("%:", false);
  var peg$e128 = peg$literalExpectation("<:", false);
  var peg$e129 = peg$literalExpectation(":>", false);
  var peg$e130 = peg$literalExpectation("<%", false);
  var peg$e131 = peg$literalExpectation("%>", false);
  var peg$e132 = peg$classExpectation(["!", "#", ["%", "&"], ["(", "/"], [":", "?"], "[", ["]", "^"], ["{", "~"]], false, false);

  var peg$f0 = function(includedModules, rootNode) { rootNode.includedModules = includedModules; return { compilationErrors, warnings, rootNode };};
  var peg$f1 = function(rootNode) { rootNode.includedModules = []; return { compilationErrors, warnings, rootNode };};
  var peg$f2 = function(items) { return createRootNode(items); };
  var peg$f3 = function(declarationSpecifier, declarator, body) { return generateFunctionDefinitionNode([declarationSpecifier], declarator, body); };
  var peg$f4 = function(declarationSpecifiers, declarator, body) { return generateFunctionDefinitionNode(declarationSpecifiers, declarator, body); };
  var peg$f5 = function(statements) { return createBlockNode(statements); };
  var peg$f6 = function() { return createBlockNode([]); };
  var peg$f7 = function(expr) { return generateNode("ReturnStatement", { value: expr === null ? undefined : expr } ); };
  var peg$f8 = function() { return generateNode("BreakStatement"); };
  var peg$f9 = function() { return generateNode("ContinueStatement"); };
  var peg$f10 = function(body, condition) { return generateNode("DoWhileLoop", { condition, body }); };
  var peg$f11 = function(condition, body) { return generateNode("WhileLoop", { condition, body }); };
  var peg$f12 = function(clause, condition, update, body) { return generateNode("ForLoop", { clause: clause === null ? null : { type: "Expression", value: clause }, condition, update, body }); };
  var peg$f13 = function(clause, condition, update, body) { return createDeclarationForLoopNode(clause, condition, update, body);  };
  var peg$f14 = function(condition, ifStatement, elseStatement) { return generateNode("SelectionStatement", { condition, ifStatement, elseStatement }); };
  var peg$f15 = function(condition, ifStatement) { return generateNode( "SelectionStatement", { condition, ifStatement }); };
  var peg$f16 = function(targetExpression, cases, defaultStatements) { return createSwitchStatementNode(targetExpression, cases, defaultStatements ?? []); };
  var peg$f17 = function(targetExpression, defaultStatements) { return createSwitchStatementNode(targetExpression, [], defaultStatements); };
  var peg$f18 = function(targetExpression) { return createSwitchStatementNode(targetExpression, [], []); };
  var peg$f19 = function(targetExpression) { warn("Statement will never be executed"); return createSwitchStatementNode(targetExpression, [], []); };
  var peg$f20 = function() { return []; };
  var peg$f21 = function(conditionMatch, statements) { return generateNode("SwitchStatementCase", { conditionMatch, statements }); };
  var peg$f22 = function(conditionMatch) { return generateNode("SwitchStatementCase", { conditionMatch, statements: [] }); };
  var peg$f23 = function(declarationSpecifier, initDeclarators) { return processDeclaration([declarationSpecifier], initDeclarators); };
  var peg$f24 = function(declarationSpecifiers, initDeclarators) { return processDeclaration(declarationSpecifiers, initDeclarators); };
  var peg$f25 = function(declarationSpecifiers, initDeclarators) { return processDeclaration(declarationSpecifiers, initDeclarators); };
  var peg$f26 = function(declarationSpecifiers) { return processDeclarationWithoutDeclarator(declarationSpecifiers); };
  var peg$f27 = function(specifier) { return generateNode("TypeSpecifier", { specifier } ); };
  var peg$f28 = function() { return generateNode("TypeQualifier", { qualifier: "const"}); };
  var peg$f29 = function(specifier) { return generateNode("StorageClassSpecifier", { specifier }); };
  var peg$f30 = function() { return { type: "TypeDefSpecifier" }; };
  var peg$f31 = function(specifier) { return generateNode("PrimaryTypeSpecifier", { specifier }); };
  var peg$f32 = function(specifier) { return generateNode("StructTypeSpecifier", { specifier }); };
  var peg$f33 = function(specifier) { return generateNode("PrimaryDataTypeLengthSpecifier", { specifier }); };
  var peg$f34 = function(specifier) { return generateNode("IntegerSignSpecifier", { specifier }); };
  var peg$f35 = function() { return generateNode("VoidTypeSpecifier"); };
  var peg$f36 = function(specifier) { return generateNode("EnumTypeSpecifier", { specifier }); };
  var peg$f37 = function(typeName) { return generateNode("UserNamedTypeSpecifier", { typeName }); };
  var peg$f38 = function(name) { return isIdentifierAType(name); };
  var peg$f39 = function(name) { return name; };
  var peg$f40 = function(declarator, initializer) { return { ...declarator, initializer  }; };
  var peg$f41 = function(pointers, directDeclarator) { return createPointerDeclaratorNode(pointers, directDeclarator); };
  var peg$f42 = function(directDeclarator) { return directDeclarator; };
  var peg$f43 = function(qualifier) { return { type: "pointer", isConst: qualifier !== null}; };
  var peg$f44 = function(value) { return createInitializerSingle(value); };
  var peg$f45 = function(list) { return createInitializerList(list); };
  var peg$f46 = function(directDeclarator, declaratorSuffixes) { return evaluateDeclaratorSuffixes(directDeclarator, declaratorSuffixes); };
  var peg$f47 = function(directDeclarator) { return evaluateDeclaratorSuffixes(directDeclarator, []); };
  var peg$f48 = function(symbolName) { return { type: "SymbolDeclarator", symbolName }; };
  var peg$f49 = function(parameters) { return createFunctionDeclarator(parameters); };
  var peg$f50 = function() { return createFunctionDeclarator(); };
  var peg$f51 = function(numElements) { return { type: "ArrayDeclarator", numElements: numElements !== null ? numElements : undefined }; };
  var peg$f52 = function(tag, fieldDeclarations) { return generateNode(tag === null ? "AnonymousStruct" : "NamedStructDefinition", createStructSpecifier(fieldDeclarations, tag)); };
  var peg$f53 = function(tag) { return generateNode(tag === null ? "AnonymousStruct" : "NamedStructDefinition", createEmptyStructSpecifier(tag)); };
  var peg$f54 = function(tag) { return generateNode("NamedStructReference", { tag } ); };
  var peg$f55 = function(declarations) { return unpackStructDeclarations(declarations); };
  var peg$f56 = function(specifier, declarators) { return processStructDeclaration([specifier], declarators); };
  var peg$f57 = function(specifiers, declarators) { return processStructDeclaration(specifiers, declarators); };
  var peg$f58 = function(specifier) { return { type: "TypeSpecifier", specifier }; };
  var peg$f59 = function(tag, enumerators) { return generateNode("NamedDefinedEnum", { tag, enumerators } ); };
  var peg$f60 = function(enumerators) { return generateNode("AnonymousEnum", { enumerators }); };
  var peg$f61 = function(tag) { return generateNode("NamedEnumReference", { tag }); };
  var peg$f62 = function(name, value) { return { name, value }; };
  var peg$f63 = function(name) { return { name }; };
  var peg$f64 = function(parameters) { return unpackParameters(parameters); };
  var peg$f65 = function(declarationSpecifier, declarator) { return processParameterDeclaration([declarationSpecifier], declarator); };
  var peg$f66 = function(declarationSpecifiers, declarator) { return processParameterDeclaration(declarationSpecifiers, declarator); };
  var peg$f67 = function(declarationSpecifiers, abstractDeclarator) { return processParameterDeclaration(declarationSpecifiers, abstractDeclarator); };
  var peg$f68 = function(declarationSpecifiers) { return processParameterDeclaration(declarationSpecifiers, null); };
  var peg$f69 = function(pointers, directAbstractDeclarator) { return createPointerDeclaratorNode(pointers, directAbstractDeclarator); };
  var peg$f70 = function(pointers) { return createPointerDeclaratorNode(pointers, { type: "AbstractDeclarator" }); };
  var peg$f71 = function(directAbstractDeclarator) { return directAbstractDeclarator; };
  var peg$f72 = function(directAbstractDeclarator, declaratorSuffixes) { return evaluateDeclaratorSuffixes(directAbstractDeclarator, declaratorSuffixes); };
  var peg$f73 = function(declaratorSuffixes) { return evaluateDeclaratorSuffixes({ type: "AbstractDeclarator" }, declaratorSuffixes); };
  var peg$f74 = function(expressions) { return generateNode("CommaSeparatedExpressions", { expressions }); };
  var peg$f75 = function(lvalue, assignmentOperator, assignedExpression) { return createAssignmentNode(lvalue, assignedExpression, assignmentOperator); };
  var peg$f76 = function(condition, trueExpression, falseExpression) { return generateNode("ConditionalExpression", { condition, trueExpression, falseExpression }); };
  var peg$f77 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };
  var peg$f78 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };
  var peg$f79 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };
  var peg$f80 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };
  var peg$f81 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };
  var peg$f82 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };
  var peg$f83 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };
  var peg$f84 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };
  var peg$f85 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };
  var peg$f86 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };
  var peg$f87 = function(operations, firstExpr) { return createPrefixExpressionNode(firstExpr, operations); };
  var peg$f88 = function(operator) { return { type: "PrefixExpression", operator }; };
  var peg$f89 = function(operator) { return { type: "PrefixExpression", operator }; };
  var peg$f90 = function(operator) { return { type: "PointerDereference" }; };
  var peg$f91 = function() { return { type: "AddressOfExpression" }; };
  var peg$f92 = function() { return { type: "SizeOfExpression", subtype: "expression" }; };
  var peg$f93 = function(firstExpr, operations) { return createPostfixExpressionNode(firstExpr, operations); };
  var peg$f94 = function(operator) { return generateNode("PostfixExpression", { operator }); };
  var peg$f95 = function(args) { return generateNode("FunctionCall", { args }); };
  var peg$f96 = function() { return generateNode("FunctionCall", { args: [] } ); };
  var peg$f97 = function(index) { return generateNode("ArrayElementExpr", { index }); };
  var peg$f98 = function(fieldTag) { return generateNode("StructMemberAccess", { fieldTag }); };
  var peg$f99 = function(fieldTag) { return generateNode("StructPointerMemberAccess", { fieldTag }); };
  var peg$f100 = function(dataType) { return createSizeOfDataTypeExpression(dataType); };
  var peg$f101 = function(name) { return isIdentifierAType(name); };
  var peg$f102 = function(name) { return generateNode("IdentifierExpression", { name }); };
  var peg$f103 = function(specifiers, declarator) { return generateDataTypeFromSpecifierAndAbstractDeclarators(specifiers, declarator); };
  var peg$f104 = function(identifier) { addIncludedModuleDefinitions(identifier); return identifier; };
  var peg$f105 = function(str) { return isStringAKeyword(str) ? false : true; };
  var peg$f106 = function(str) { return str; };
  var peg$f107 = function(value, suffix) { return generateIntegerConstant(value, suffix); };
  var peg$f108 = function(value) { return "0o" + value; };
  var peg$f109 = function(value, suffix) { return generateFloatConstant(value, suffix); };
  var peg$f110 = function(value, suffix) { return generateFloatConstant(value, suffix); };
  var peg$f111 = function(name) { return isIdentifierAType(name); };
  var peg$f112 = function(name) { return name; };
  var peg$f113 = function(value) { return generateNode("IntegerConstant", { value: BigInt(value) }); };
  var peg$f114 = function(char) { return char.charCodeAt(0); };
  var peg$f115 = function(char) { return char.charCodeAt(0); };
  var peg$f116 = function() { return 39; };
  var peg$f117 = function() { return 34; };
  var peg$f118 = function() { return 63; };
  var peg$f119 = function() { return 92; };
  var peg$f120 = function() { return 7; };
  var peg$f121 = function() { return 8; };
  var peg$f122 = function() { return 12; };
  var peg$f123 = function() { return 13; };
  var peg$f124 = function() { return 10; };
  var peg$f125 = function() { return 9; };
  var peg$f126 = function() { return 11; };
  var peg$f127 = function(value) { return parseInt(value, 8); };
  var peg$f128 = function(value) { return parseInt(value, 16); };
  var peg$f129 = function(chars) { chars.push(0); return generateNode("StringLiteral", { chars }); };
  var peg$f130 = function(char) { return char.charCodeAt(0); };
  var peg$currPos = options.peg$currPos | 0;
  var peg$savedPos = peg$currPos;
  var peg$posDetailsCache = [{ line: 1, column: 1 }];
  var peg$maxFailPos = peg$currPos;
  var peg$maxFailExpected = options.peg$maxFailExpected || [];
  var peg$silentFails = options.peg$silentFails | 0;

  var peg$resultsCache = {};

  var peg$result;

  if (options.startRule) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function offset() {
    return peg$savedPos;
  }

  function range() {
    return {
      source: peg$source,
      start: peg$savedPos,
      end: peg$currPos
    };
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== undefined
      ? location
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== undefined
      ? location
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos];
    var p;

    if (details) {
      return details;
    } else {
      if (pos >= peg$posDetailsCache.length) {
        p = peg$posDetailsCache.length - 1;
      } else {
        p = pos;
        while (!peg$posDetailsCache[--p]) {}
      }

      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;

      return details;
    }
  }

  function peg$computeLocation(startPos, endPos, offset) {
    var startPosDetails = peg$computePosDetails(startPos);
    var endPosDetails = peg$computePosDetails(endPos);

    var res = {
      source: peg$source,
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
    if (offset && peg$source && (typeof peg$source.offset === "function")) {
      res.start = peg$source.offset(res.start);
      res.end = peg$source.offset(res.end);
    }
    return res;
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parseprogram() {
    var s0, s1, s2, s3, s4;

    var key = peg$currPos * 105 + 0;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = [];
    s3 = peg$parseinclude();
    while (s3 !== peg$FAILED) {
      s2.push(s3);
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        s4 = peg$parseinclude();
        if (s4 === peg$FAILED) {
          peg$currPos = s3;
          s3 = peg$FAILED;
        } else {
          s3 = s4;
        }
      } else {
        s3 = s4;
      }
    }
    if (s2.length < 1) {
      peg$currPos = s1;
      s1 = peg$FAILED;
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsetranslation_unit();
        s4 = peg$parse_();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f0(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsetranslation_unit();
      s2 = peg$parse_();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f1(s1);
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parse_() {
    var s0, s1;

    var key = peg$currPos * 105 + 1;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    peg$silentFails++;
    if (input.charCodeAt(peg$currPos) === 32) {
      s0 = peg$c0;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e1); }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e0); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsetranslation_unit() {
    var s0, s1, s2, s3;

    var key = peg$currPos * 105 + 2;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsefunction_definition();
    if (s2 === peg$FAILED) {
      s2 = peg$parsedeclaration();
    }
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;
      s3 = peg$parse_();
      if (s3 !== peg$FAILED) {
        s3 = peg$parsefunction_definition();
        if (s3 === peg$FAILED) {
          s3 = peg$parsedeclaration();
        }
        if (s3 === peg$FAILED) {
          peg$currPos = s2;
          s2 = peg$FAILED;
        } else {
          s2 = s3;
        }
      } else {
        s2 = s3;
      }
    }
    peg$savedPos = s0;
    s1 = peg$f2(s1);
    s0 = s1;

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsefunction_definition() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 3;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsedeclaration_specifier();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsedeclarator();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecompound_statement();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f3(s1, s3, s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsedeclaration_specifiers();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsedeclarator();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecompound_statement();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f4(s1, s3, s5);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsestatement() {
    var s0;

    var key = peg$currPos * 105 + 4;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$parseiteration_statement();
    if (s0 === peg$FAILED) {
      s0 = peg$parsecompound_statement();
      if (s0 === peg$FAILED) {
        s0 = peg$parsejump_statement();
        if (s0 === peg$FAILED) {
          s0 = peg$parseexpression_statement();
          if (s0 === peg$FAILED) {
            s0 = peg$parseselection_statement();
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsecompound_statement() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 5;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c1;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e3); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseblock_item_list();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c2;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e4); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f5(s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c1;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e3); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 125) {
            s3 = peg$c2;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e4); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e2); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseblock_item_list() {
    var s0, s1, s2, s3;

    var key = peg$currPos * 105 + 6;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseblock_item();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;
      s3 = peg$parse_();
      if (s3 !== peg$FAILED) {
        s3 = peg$parseblock_item();
        if (s3 === peg$FAILED) {
          peg$currPos = s2;
          s2 = peg$FAILED;
        } else {
          s2 = s3;
        }
      } else {
        s2 = s3;
      }
    }
    if (s1.length < 1) {
      peg$currPos = s0;
      s0 = peg$FAILED;
    } else {
      s0 = s1;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseblock_item() {
    var s0;

    var key = peg$currPos * 105 + 7;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$parsestatement();
    if (s0 === peg$FAILED) {
      s0 = peg$parsedeclaration();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsejump_statement() {
    var s0, s1, s2, s3, s4;

    var key = peg$currPos * 105 + 8;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6) === peg$c3) {
      s1 = peg$c3;
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e5); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parse_();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseexpression();
        if (s4 !== peg$FAILED) {
          s2 = s4;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parse_();
      if (s3 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 59) {
          s4 = peg$c4;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e6); }
        }
        if (s4 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f7(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c5) {
        s1 = peg$c5;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e7); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 59) {
            s3 = peg$c4;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e6); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f8();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 8) === peg$c6) {
          s1 = peg$c6;
          peg$currPos += 8;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e8); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 59) {
              s3 = peg$c4;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e6); }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f9();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseexpression_statement() {
    var s0, s1, s2, s3;

    var key = peg$currPos * 105 + 9;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseexpression();
    if (s2 !== peg$FAILED) {
      s3 = peg$parse_();
      if (s3 !== peg$FAILED) {
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (input.charCodeAt(peg$currPos) === 59) {
      s2 = peg$c4;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e6); }
    }
    if (s2 !== peg$FAILED) {
      s0 = s1;
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseiteration_statement() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;

    var key = peg$currPos * 105 + 10;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c7) {
      s1 = peg$c7;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e9); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsestatement();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c8) {
              s5 = peg$c8;
              peg$currPos += 5;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e10); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 40) {
                  s7 = peg$c9;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$e11); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseexpression();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 41) {
                          s11 = peg$c10;
                          peg$currPos++;
                        } else {
                          s11 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$e12); }
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse_();
                          if (s12 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 59) {
                              s13 = peg$c4;
                              peg$currPos++;
                            } else {
                              s13 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$e6); }
                            }
                            if (s13 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s0 = peg$f10(s3, s9);
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c8) {
        s1 = peg$c8;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e10); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c9;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e11); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseexpression();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s7 = peg$c10;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e12); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsestatement();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f11(s5, s9);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c11) {
          s1 = peg$c11;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e13); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 40) {
              s3 = peg$c9;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e11); }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = peg$currPos;
                s6 = peg$parseexpression();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                if (input.charCodeAt(peg$currPos) === 59) {
                  s6 = peg$c4;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$e6); }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$currPos;
                    s9 = peg$parseexpression();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s8 = s9;
                      } else {
                        peg$currPos = s8;
                        s8 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                    if (s8 === peg$FAILED) {
                      s8 = null;
                    }
                    if (input.charCodeAt(peg$currPos) === 59) {
                      s9 = peg$c4;
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$e6); }
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$currPos;
                        s12 = peg$parseexpression();
                        if (s12 !== peg$FAILED) {
                          s13 = peg$parse_();
                          if (s13 !== peg$FAILED) {
                            s11 = s12;
                          } else {
                            peg$currPos = s11;
                            s11 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s11;
                          s11 = peg$FAILED;
                        }
                        if (s11 === peg$FAILED) {
                          s11 = null;
                        }
                        if (input.charCodeAt(peg$currPos) === 41) {
                          s12 = peg$c10;
                          peg$currPos++;
                        } else {
                          s12 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$e12); }
                        }
                        if (s12 !== peg$FAILED) {
                          s13 = peg$parse_();
                          if (s13 !== peg$FAILED) {
                            s14 = peg$parsestatement();
                            if (s14 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s0 = peg$f12(s5, s8, s11, s14);
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c11) {
            s1 = peg$c11;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e13); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c9;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e11); }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsedeclaration();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$currPos;
                      s8 = peg$parseexpression();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parse_();
                        if (s9 !== peg$FAILED) {
                          s7 = s8;
                        } else {
                          peg$currPos = s7;
                          s7 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                      if (s7 === peg$FAILED) {
                        s7 = null;
                      }
                      if (input.charCodeAt(peg$currPos) === 59) {
                        s8 = peg$c4;
                        peg$currPos++;
                      } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$e6); }
                      }
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parse_();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$currPos;
                          s11 = peg$parseexpression();
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parse_();
                            if (s12 !== peg$FAILED) {
                              s10 = s11;
                            } else {
                              peg$currPos = s10;
                              s10 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s10;
                            s10 = peg$FAILED;
                          }
                          if (s10 === peg$FAILED) {
                            s10 = null;
                          }
                          if (input.charCodeAt(peg$currPos) === 41) {
                            s11 = peg$c10;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$e12); }
                          }
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parse_();
                            if (s12 !== peg$FAILED) {
                              s13 = peg$parsestatement();
                              if (s13 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s0 = peg$f13(s5, s7, s10, s13);
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseselection_statement() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;

    var key = peg$currPos * 105 + 11;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c12) {
      s1 = peg$c12;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e14); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 40) {
          s3 = peg$c9;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e11); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseexpression();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s7 = peg$c10;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$e12); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsestatement();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 4) === peg$c13) {
                          s11 = peg$c13;
                          peg$currPos += 4;
                        } else {
                          s11 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$e15); }
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse_();
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parsestatement();
                            if (s13 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s0 = peg$f14(s5, s9, s13);
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c12) {
        s1 = peg$c12;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e14); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c9;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e11); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseexpression();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s7 = peg$c10;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e12); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsestatement();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f15(s5, s9);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c14) {
          s1 = peg$c14;
          peg$currPos += 6;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e16); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 40) {
              s3 = peg$c9;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e11); }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseexpression();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s7 = peg$c10;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$e12); }
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parse_();
                      if (s8 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 123) {
                          s9 = peg$c1;
                          peg$currPos++;
                        } else {
                          s9 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$e3); }
                        }
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parse_();
                          if (s10 !== peg$FAILED) {
                            s11 = peg$currPos;
                            s12 = [];
                            s13 = peg$parseswitch_statement_case();
                            while (s13 !== peg$FAILED) {
                              s12.push(s13);
                              s13 = peg$currPos;
                              s14 = peg$parse_();
                              if (s14 !== peg$FAILED) {
                                s14 = peg$parseswitch_statement_case();
                                if (s14 === peg$FAILED) {
                                  peg$currPos = s13;
                                  s13 = peg$FAILED;
                                } else {
                                  s13 = s14;
                                }
                              } else {
                                s13 = s14;
                              }
                            }
                            if (s12.length < 1) {
                              peg$currPos = s11;
                              s11 = peg$FAILED;
                            } else {
                              s11 = s12;
                            }
                            if (s11 !== peg$FAILED) {
                              s12 = peg$currPos;
                              s13 = peg$parse_();
                              if (s13 !== peg$FAILED) {
                                s14 = peg$parseswitch_default_case();
                                if (s14 !== peg$FAILED) {
                                  s12 = s14;
                                } else {
                                  peg$currPos = s12;
                                  s12 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s12;
                                s12 = peg$FAILED;
                              }
                              if (s12 === peg$FAILED) {
                                s12 = null;
                              }
                              s13 = peg$parse_();
                              if (s13 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 125) {
                                  s14 = peg$c2;
                                  peg$currPos++;
                                } else {
                                  s14 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$e4); }
                                }
                                if (s14 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s0 = peg$f16(s5, s11, s12);
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c14) {
            s1 = peg$c14;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e16); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c9;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e11); }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseexpression();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 41) {
                        s7 = peg$c10;
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$e12); }
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parse_();
                        if (s8 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 123) {
                            s9 = peg$c1;
                            peg$currPos++;
                          } else {
                            s9 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$e3); }
                          }
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parse_();
                            if (s10 !== peg$FAILED) {
                              s11 = peg$parseswitch_default_case();
                              if (s11 !== peg$FAILED) {
                                s12 = peg$parse_();
                                if (s12 !== peg$FAILED) {
                                  if (input.charCodeAt(peg$currPos) === 125) {
                                    s13 = peg$c2;
                                    peg$currPos++;
                                  } else {
                                    s13 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$e4); }
                                  }
                                  if (s13 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s0 = peg$f17(s5, s11);
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 6) === peg$c14) {
              s1 = peg$c14;
              peg$currPos += 6;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e16); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 40) {
                  s3 = peg$c9;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$e11); }
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseexpression();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parse_();
                      if (s6 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 41) {
                          s7 = peg$c10;
                          peg$currPos++;
                        } else {
                          s7 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$e12); }
                        }
                        if (s7 !== peg$FAILED) {
                          s8 = peg$parse_();
                          if (s8 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 123) {
                              s9 = peg$c1;
                              peg$currPos++;
                            } else {
                              s9 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$e3); }
                            }
                            if (s9 !== peg$FAILED) {
                              s10 = peg$parse_();
                              if (s10 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 125) {
                                  s11 = peg$c2;
                                  peg$currPos++;
                                } else {
                                  s11 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$e4); }
                                }
                                if (s11 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s0 = peg$f18(s5);
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 6) === peg$c14) {
                s1 = peg$c14;
                peg$currPos += 6;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e16); }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 40) {
                    s3 = peg$c9;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e11); }
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parseexpression();
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parse_();
                        if (s6 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 41) {
                            s7 = peg$c10;
                            peg$currPos++;
                          } else {
                            s7 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$e12); }
                          }
                          if (s7 !== peg$FAILED) {
                            s8 = peg$parse_();
                            if (s8 !== peg$FAILED) {
                              s9 = peg$parsestatement();
                              if (s9 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s0 = peg$f19(s5);
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseswitch_default_case() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 12;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7) === peg$c15) {
      s1 = peg$c15;
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e17); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s3 = peg$c16;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e18); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseblock_item_list();
            if (s5 !== peg$FAILED) {
              s0 = s5;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 7) === peg$c15) {
        s1 = peg$c15;
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e17); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s3 = peg$c16;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e18); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f20();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseswitch_statement_case() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key = peg$currPos * 105 + 13;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c17) {
      s1 = peg$c17;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e19); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseconditional_expression();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s5 = peg$c16;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e18); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseblock_item_list();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f21(s3, s7);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c17) {
        s1 = peg$c17;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e19); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseconditional_expression();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s5 = peg$c16;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e18); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f22(s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsedeclaration() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 14;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsedeclaration_specifier();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseinit_declarator_list();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 59) {
              s5 = peg$c4;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e6); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f23(s1, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = [];
      s3 = peg$parsedeclaration_specifier();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        if (s2.length >= 2) {
          s3 = peg$FAILED;
        } else {
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s4 = peg$parsedeclaration_specifier();
            if (s4 === peg$FAILED) {
              peg$currPos = s3;
              s3 = peg$FAILED;
            } else {
              s3 = s4;
            }
          } else {
            s3 = s4;
          }
        }
      }
      if (s2.length < 2) {
        peg$currPos = s1;
        s1 = peg$FAILED;
      } else {
        s1 = s2;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseinit_declarator_list();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 59) {
                s5 = peg$c4;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e6); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f24(s1, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsedeclaration_specifiers();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseinit_declarator_list();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 59) {
                  s5 = peg$c4;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$e6); }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f25(s1, s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsedeclaration_specifiers();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 59) {
                s3 = peg$c4;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e6); }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f26(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsedeclaration_specifiers() {
    var s0, s1, s2, s3;

    var key = peg$currPos * 105 + 15;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsedeclaration_specifier();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;
      s3 = peg$parse_();
      if (s3 !== peg$FAILED) {
        s3 = peg$parsedeclaration_specifier();
        if (s3 === peg$FAILED) {
          peg$currPos = s2;
          s2 = peg$FAILED;
        } else {
          s2 = s3;
        }
      } else {
        s2 = s3;
      }
    }
    if (s1.length < 1) {
      peg$currPos = s0;
      s0 = peg$FAILED;
    } else {
      s0 = s1;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsedeclaration_specifier() {
    var s0, s1;

    var key = peg$currPos * 105 + 16;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$parsetype_qualifier();
    if (s0 === peg$FAILED) {
      s0 = peg$parsestorage_class_specifier();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsetype_specifier();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f27(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$parsetypedef_specifier();
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsetype_qualifier() {
    var s0, s1;

    var key = peg$currPos * 105 + 17;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5) === peg$c18) {
      s1 = peg$c18;
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e20); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f28();
    }
    s0 = s1;

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsestorage_class_specifier() {
    var s0, s1;

    var key = peg$currPos * 105 + 18;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c19) {
      s1 = peg$c19;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e21); }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 6) === peg$c20) {
        s1 = peg$c20;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e22); }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f29(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsetypedef_specifier() {
    var s0, s1;

    var key = peg$currPos * 105 + 19;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7) === peg$c21) {
      s1 = peg$c21;
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e23); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f30();
    }
    s0 = s1;

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsetype_specifier() {
    var s0, s1;

    var key = peg$currPos * 105 + 20;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseprimary_data_type_specifier();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f31(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsestruct_specifier();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f32(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseprimary_data_type_length_specifier();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f33(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseinteger_sign_type_specifier();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f34(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 4) === peg$c22) {
              s1 = peg$c22;
              peg$currPos += 4;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e24); }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f35();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseenum_specifier();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f36(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsetypedef_name();
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$f37(s1);
                }
                s0 = s1;
              }
            }
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseprimary_data_type_specifier() {
    var s0;

    var key = peg$currPos * 105 + 21;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    if (input.substr(peg$currPos, 4) === peg$c23) {
      s0 = peg$c23;
      peg$currPos += 4;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e25); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 3) === peg$c24) {
        s0 = peg$c24;
        peg$currPos += 3;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e26); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 5) === peg$c25) {
          s0 = peg$c25;
          peg$currPos += 5;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e27); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c26) {
            s0 = peg$c26;
            peg$currPos += 6;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e28); }
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseprimary_data_type_length_specifier() {
    var s0;

    var key = peg$currPos * 105 + 22;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    if (input.substr(peg$currPos, 4) === peg$c27) {
      s0 = peg$c27;
      peg$currPos += 4;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e29); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 5) === peg$c28) {
        s0 = peg$c28;
        peg$currPos += 5;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e30); }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseinteger_sign_type_specifier() {
    var s0;

    var key = peg$currPos * 105 + 23;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    if (input.substr(peg$currPos, 6) === peg$c29) {
      s0 = peg$c29;
      peg$currPos += 6;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e31); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 8) === peg$c30) {
        s0 = peg$c30;
        peg$currPos += 8;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e32); }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsetypedef_name() {
    var s0, s1, s2;

    var key = peg$currPos * 105 + 24;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseidentifier();
    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$f38(s1);
      if (s2) {
        s2 = undefined;
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f39(s1);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseinit_declarator_list() {
    var s0, s1, s2, s3, s4, s5, s6;

    var key = peg$currPos * 105 + 25;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseinit_declarator();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c31;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e33); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s4 = [s4, s5, s6];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s3 = peg$parseinit_declarator();
        if (s3 === peg$FAILED) {
          peg$currPos = s2;
          s2 = peg$FAILED;
        } else {
          s2 = s3;
        }
      } else {
        s2 = s3;
      }
    }
    if (s1.length < 1) {
      peg$currPos = s0;
      s0 = peg$FAILED;
    } else {
      s0 = s1;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseinit_declarator() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 26;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsedeclarator();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          s3 = peg$c32;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e34); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseinitializer();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f40(s1, s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsedeclarator();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsedeclarator() {
    var s0, s1, s2, s3;

    var key = peg$currPos * 105 + 27;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsepointer();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsedirect_declarator();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f41(s1, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsedirect_declarator();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f42(s1);
      }
      s0 = s1;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsepointer() {
    var s0, s1, s2, s3;

    var key = peg$currPos * 105 + 28;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsepointer_with_qualifier();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;
      s3 = peg$parse_();
      if (s3 !== peg$FAILED) {
        s3 = peg$parsepointer_with_qualifier();
        if (s3 === peg$FAILED) {
          peg$currPos = s2;
          s2 = peg$FAILED;
        } else {
          s2 = s3;
        }
      } else {
        s2 = s3;
      }
    }
    if (s1.length < 1) {
      peg$currPos = s0;
      s0 = peg$FAILED;
    } else {
      s0 = s1;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsepointer_with_qualifier() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key = peg$currPos * 105 + 29;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 42) {
      s1 = peg$c33;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e35); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parse_();
      if (s3 !== peg$FAILED) {
        s4 = peg$currPos;
        s5 = [];
        s6 = peg$parsetype_qualifier();
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          s6 = peg$currPos;
          s7 = peg$parse_();
          if (s7 !== peg$FAILED) {
            s7 = peg$parsetype_qualifier();
            if (s7 === peg$FAILED) {
              peg$currPos = s6;
              s6 = peg$FAILED;
            } else {
              s6 = s7;
            }
          } else {
            s6 = s7;
          }
        }
        if (s5.length < 1) {
          peg$currPos = s4;
          s4 = peg$FAILED;
        } else {
          s4 = s5;
        }
        if (s4 !== peg$FAILED) {
          s2 = s4;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f43(s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseinitializer() {
    var s0, s1;

    var key = peg$currPos * 105 + 30;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$parselist_initializer();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseassignment_expression();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f44(s1);
      }
      s0 = s1;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parselist_initializer() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    var key = peg$currPos * 105 + 31;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c1;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e3); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = [];
        s5 = peg$parseinitializer();
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$currPos;
          s6 = peg$currPos;
          s7 = peg$parse_();
          if (s7 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s8 = peg$c31;
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e33); }
            }
            if (s8 !== peg$FAILED) {
              s9 = peg$parse_();
              if (s9 !== peg$FAILED) {
                s7 = [s7, s8, s9];
                s6 = s7;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            s6 = peg$parseinitializer();
            if (s6 === peg$FAILED) {
              peg$currPos = s5;
              s5 = peg$FAILED;
            } else {
              s5 = s6;
            }
          } else {
            s5 = s6;
          }
        }
        s5 = peg$parse_();
        if (s5 !== peg$FAILED) {
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        s4 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c31;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e33); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s4 = s5;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        if (input.charCodeAt(peg$currPos) === 125) {
          s5 = peg$c2;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e4); }
        }
        if (s5 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f45(s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsedirect_declarator() {
    var s0, s1, s2, s3, s4, s5, s6;

    var key = peg$currPos * 105 + 32;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsedirect_declarator_helper();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = [];
        s5 = peg$parsefunction_declarator_suffix();
        if (s5 === peg$FAILED) {
          s5 = peg$parsearray_declarator_suffix();
        }
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$currPos;
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s6 = peg$parsefunction_declarator_suffix();
            if (s6 === peg$FAILED) {
              s6 = peg$parsearray_declarator_suffix();
            }
            if (s6 === peg$FAILED) {
              peg$currPos = s5;
              s5 = peg$FAILED;
            } else {
              s5 = s6;
            }
          } else {
            s5 = s6;
          }
        }
        if (s4.length < 1) {
          peg$currPos = s3;
          s3 = peg$FAILED;
        } else {
          s3 = s4;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f46(s1, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsedirect_declarator_helper();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f47(s1);
      }
      s0 = s1;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsedirect_declarator_helper() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 33;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseidentifier();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f48(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c9;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e11); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsedeclarator();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c10;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e12); }
              }
              if (s5 !== peg$FAILED) {
                s0 = s3;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsefunction_declarator_suffix() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 34;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 40) {
      s1 = peg$c9;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e11); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseparameter_list();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s5 = peg$c10;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e12); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f49(s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c9;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e11); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s3 = peg$c10;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e12); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f50();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsearray_declarator_suffix() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 35;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      s1 = peg$c34;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e36); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseassignment_expression();
        if (s4 !== peg$FAILED) {
          s5 = peg$parse_();
          if (s5 !== peg$FAILED) {
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (input.charCodeAt(peg$currPos) === 93) {
          s4 = peg$c35;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e37); }
        }
        if (s4 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f51(s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsestruct_specifier() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

    var key = peg$currPos * 105 + 36;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6) === peg$c36) {
      s1 = peg$c36;
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e38); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseidentifier();
        if (s4 !== peg$FAILED) {
          s5 = peg$parse_();
          if (s5 !== peg$FAILED) {
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (input.charCodeAt(peg$currPos) === 123) {
          s4 = peg$c1;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e3); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parse_();
          if (s5 !== peg$FAILED) {
            s6 = peg$parsestruct_declaration_list();
            if (s6 !== peg$FAILED) {
              s7 = peg$parse_();
              if (s7 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s8 = peg$c2;
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$e4); }
                }
                if (s8 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f52(s3, s6);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c36) {
        s1 = peg$c36;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e38); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseidentifier();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (input.charCodeAt(peg$currPos) === 123) {
            s4 = peg$c1;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e3); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s6 = peg$c2;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e4); }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f53(s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c36) {
          s1 = peg$c36;
          peg$currPos += 6;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e38); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseidentifier();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f54(s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsestruct_declaration_list() {
    var s0, s1, s2, s3, s4;

    var key = peg$currPos * 105 + 37;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = [];
    s3 = peg$parsestruct_declaration();
    while (s3 !== peg$FAILED) {
      s2.push(s3);
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        s4 = peg$parsestruct_declaration();
        if (s4 === peg$FAILED) {
          peg$currPos = s3;
          s3 = peg$FAILED;
        } else {
          s3 = s4;
        }
      } else {
        s3 = s4;
      }
    }
    if (s2.length < 1) {
      peg$currPos = s1;
      s1 = peg$FAILED;
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f55(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsestruct_declaration() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 38;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsespecifier_qualifier_list_item();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsestruct_declarator_list();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 59) {
              s5 = peg$c4;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e6); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f56(s1, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsespecifier_qualifier_list();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsestruct_declarator_list();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 59) {
                s5 = peg$c4;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e6); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f57(s1, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsespecifier_qualifier_list() {
    var s0, s1, s2, s3;

    var key = peg$currPos * 105 + 39;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsespecifier_qualifier_list_item();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;
      s3 = peg$parse_();
      if (s3 !== peg$FAILED) {
        s3 = peg$parsespecifier_qualifier_list_item();
        if (s3 === peg$FAILED) {
          peg$currPos = s2;
          s2 = peg$FAILED;
        } else {
          s2 = s3;
        }
      } else {
        s2 = s3;
      }
    }
    if (s1.length < 1) {
      peg$currPos = s0;
      s0 = peg$FAILED;
    } else {
      s0 = s1;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsespecifier_qualifier_list_item() {
    var s0, s1;

    var key = peg$currPos * 105 + 40;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsetype_specifier();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f58(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$parsetype_qualifier();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsestruct_declarator_list() {
    var s0, s1, s2, s3, s4, s5, s6;

    var key = peg$currPos * 105 + 41;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsedeclarator();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c31;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e33); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s4 = [s4, s5, s6];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s3 = peg$parsedeclarator();
        if (s3 === peg$FAILED) {
          peg$currPos = s2;
          s2 = peg$FAILED;
        } else {
          s2 = s3;
        }
      } else {
        s2 = s3;
      }
    }
    if (s1.length < 1) {
      peg$currPos = s0;
      s0 = peg$FAILED;
    } else {
      s0 = s1;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseenum_specifier() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

    var key = peg$currPos * 105 + 42;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c37) {
      s1 = peg$c37;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e39); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseidentifier();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
              s5 = peg$c1;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e3); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseenumerator_list();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s10 = peg$c31;
                      peg$currPos++;
                    } else {
                      s10 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$e33); }
                    }
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parse_();
                      if (s11 !== peg$FAILED) {
                        s10 = [s10, s11];
                        s9 = s10;
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s10 = peg$c2;
                      peg$currPos++;
                    } else {
                      s10 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$e4); }
                    }
                    if (s10 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s0 = peg$f59(s3, s7);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c37) {
        s1 = peg$c37;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e39); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 123) {
            s3 = peg$c1;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e3); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseenumerator_list();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  s7 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s8 = peg$c31;
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e33); }
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_();
                    if (s9 !== peg$FAILED) {
                      s8 = [s8, s9];
                      s7 = s8;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  if (s7 === peg$FAILED) {
                    s7 = null;
                  }
                  if (input.charCodeAt(peg$currPos) === 125) {
                    s8 = peg$c2;
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e4); }
                  }
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f60(s5);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c37) {
          s1 = peg$c37;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e39); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseidentifier();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f61(s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseenumerator_list() {
    var s0, s1, s2, s3, s4, s5, s6;

    var key = peg$currPos * 105 + 43;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseenumerator();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c31;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e33); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s4 = [s4, s5, s6];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s3 = peg$parseenumerator();
        if (s3 === peg$FAILED) {
          peg$currPos = s2;
          s2 = peg$FAILED;
        } else {
          s2 = s3;
        }
      } else {
        s2 = s3;
      }
    }
    if (s1.length < 1) {
      peg$currPos = s0;
      s0 = peg$FAILED;
    } else {
      s0 = s1;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseenumerator() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 44;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseenumeration_constant();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          s3 = peg$c32;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e34); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseconditional_expression();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f62(s1, s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseenumeration_constant();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f63(s1);
      }
      s0 = s1;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseparameter_list() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key = peg$currPos * 105 + 45;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = [];
    s3 = peg$parseparameter_declaration();
    while (s3 !== peg$FAILED) {
      s2.push(s3);
      s3 = peg$currPos;
      s4 = peg$currPos;
      s5 = peg$parse_();
      if (s5 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s6 = peg$c31;
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e33); }
        }
        if (s6 !== peg$FAILED) {
          s7 = peg$parse_();
          if (s7 !== peg$FAILED) {
            s5 = [s5, s6, s7];
            s4 = s5;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s4 = peg$parseparameter_declaration();
        if (s4 === peg$FAILED) {
          peg$currPos = s3;
          s3 = peg$FAILED;
        } else {
          s3 = s4;
        }
      } else {
        s3 = s4;
      }
    }
    if (s2.length < 1) {
      peg$currPos = s1;
      s1 = peg$FAILED;
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f64(s1);
    }
    s0 = s1;

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseparameter_declaration() {
    var s0, s1, s2, s3;

    var key = peg$currPos * 105 + 46;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsedeclaration_specifier();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsedeclarator();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f65(s1, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsedeclaration_specifiers();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsedeclarator();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f66(s1, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsedeclaration_specifiers();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseabstract_declarator();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f67(s1, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsedeclaration_specifiers();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f68(s1);
          }
          s0 = s1;
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseabstract_declarator() {
    var s0, s1, s2, s3;

    var key = peg$currPos * 105 + 47;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsepointer();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsedirect_abstract_declarator();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f69(s1, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsepointer();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f70(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsedirect_abstract_declarator();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f71(s1);
        }
        s0 = s1;
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsedirect_abstract_declarator() {
    var s0, s1, s2, s3, s4, s5, s6;

    var key = peg$currPos * 105 + 48;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsedirect_abstract_declarator_helper();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = [];
        s5 = peg$parsefunction_declarator_suffix();
        if (s5 === peg$FAILED) {
          s5 = peg$parsearray_declarator_suffix();
        }
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$currPos;
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s6 = peg$parsefunction_declarator_suffix();
            if (s6 === peg$FAILED) {
              s6 = peg$parsearray_declarator_suffix();
            }
            if (s6 === peg$FAILED) {
              peg$currPos = s5;
              s5 = peg$FAILED;
            } else {
              s5 = s6;
            }
          } else {
            s5 = s6;
          }
        }
        if (s4.length < 1) {
          peg$currPos = s3;
          s3 = peg$FAILED;
        } else {
          s3 = s4;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f72(s1, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = [];
      s3 = peg$parsefunction_declarator_suffix();
      if (s3 === peg$FAILED) {
        s3 = peg$parsearray_declarator_suffix();
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s4 = peg$parsefunction_declarator_suffix();
          if (s4 === peg$FAILED) {
            s4 = peg$parsearray_declarator_suffix();
          }
          if (s4 === peg$FAILED) {
            peg$currPos = s3;
            s3 = peg$FAILED;
          } else {
            s3 = s4;
          }
        } else {
          s3 = s4;
        }
      }
      if (s2.length < 1) {
        peg$currPos = s1;
        s1 = peg$FAILED;
      } else {
        s1 = s2;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f73(s1);
      }
      s0 = s1;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsedirect_abstract_declarator_helper() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 49;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 40) {
      s1 = peg$c9;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e11); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseabstract_declarator();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s5 = peg$c10;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e12); }
            }
            if (s5 !== peg$FAILED) {
              s0 = s3;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseexpression() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key = peg$currPos * 105 + 50;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = [];
    s3 = peg$parseassignment_expression();
    while (s3 !== peg$FAILED) {
      s2.push(s3);
      s3 = peg$currPos;
      s4 = peg$currPos;
      s5 = peg$parse_();
      if (s5 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s6 = peg$c31;
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e33); }
        }
        if (s6 !== peg$FAILED) {
          s7 = peg$parse_();
          if (s7 !== peg$FAILED) {
            s5 = [s5, s6, s7];
            s4 = s5;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s4 = peg$parseassignment_expression();
        if (s4 === peg$FAILED) {
          peg$currPos = s3;
          s3 = peg$FAILED;
        } else {
          s3 = s4;
        }
      } else {
        s3 = s4;
      }
    }
    if (s2.length < 2) {
      peg$currPos = s1;
      s1 = peg$FAILED;
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f74(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$parseassignment_expression();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseassignment_expression() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 51;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseunary_expression();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseassignment_operator();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseassignment_expression();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f75(s1, s3, s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseconditional_expression();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseassignment_operator() {
    var s0;

    var key = peg$currPos * 105 + 52;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    if (input.substr(peg$currPos, 2) === peg$c38) {
      s0 = peg$c38;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e40); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c39) {
        s0 = peg$c39;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e41); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c40) {
          s0 = peg$c40;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e42); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c41) {
            s0 = peg$c41;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e43); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c42) {
              s0 = peg$c42;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e44); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c43) {
                s0 = peg$c43;
                peg$currPos += 3;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e45); }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c44) {
                  s0 = peg$c44;
                  peg$currPos += 3;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$e46); }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c45) {
                    s0 = peg$c45;
                    peg$currPos += 2;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e47); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c46) {
                      s0 = peg$c46;
                      peg$currPos += 2;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$e48); }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c47) {
                        s0 = peg$c47;
                        peg$currPos += 2;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$e49); }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 61) {
                          s0 = peg$c32;
                          peg$currPos++;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$e34); }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseconditional_expression() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    var key = peg$currPos * 105 + 53;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parselogical_or_expression();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 63) {
          s3 = peg$c48;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e50); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseexpression();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                  s7 = peg$c16;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$e18); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseconditional_expression();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s0 = peg$f76(s1, s5, s9);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parselogical_or_expression();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parselogical_or_expression() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key = peg$currPos * 105 + 54;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parselogical_and_expression();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c49) {
          s5 = peg$c49;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e51); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parselogical_and_expression();
            if (s7 !== peg$FAILED) {
              s3 = [ s5, s7 ];
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c49) {
              s5 = peg$c49;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e51); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parselogical_and_expression();
                if (s7 !== peg$FAILED) {
                  s3 = [ s5, s7 ];
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f77(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parselogical_and_expression();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parselogical_and_expression() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key = peg$currPos * 105 + 55;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsebitwise_or_expression();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c50) {
          s5 = peg$c50;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e52); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsebitwise_or_expression();
            if (s7 !== peg$FAILED) {
              s3 = [ s5, s7 ];
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c50) {
              s5 = peg$c50;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e52); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsebitwise_or_expression();
                if (s7 !== peg$FAILED) {
                  s3 = [ s5, s7 ];
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f78(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsebitwise_or_expression();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsebitwise_or_expression() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key = peg$currPos * 105 + 56;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsebitwise_xor_expression();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 124) {
          s5 = peg$c51;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e53); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsebitwise_xor_expression();
            if (s7 !== peg$FAILED) {
              s3 = [ s5, s7 ];
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 124) {
              s5 = peg$c51;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e53); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsebitwise_xor_expression();
                if (s7 !== peg$FAILED) {
                  s3 = [ s5, s7 ];
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f79(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsebitwise_xor_expression();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsebitwise_xor_expression() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key = peg$currPos * 105 + 57;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsebitwise_and_expression();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 94) {
          s5 = peg$c52;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e54); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsebitwise_and_expression();
            if (s7 !== peg$FAILED) {
              s3 = [ s5, s7 ];
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 94) {
              s5 = peg$c52;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e54); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsebitwise_and_expression();
                if (s7 !== peg$FAILED) {
                  s3 = [ s5, s7 ];
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f80(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsebitwise_and_expression();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsebitwise_and_expression() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key = peg$currPos * 105 + 58;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseequality_relational_expression();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 38) {
          s5 = peg$c53;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e55); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseequality_relational_expression();
            if (s7 !== peg$FAILED) {
              s3 = [ s5, s7 ];
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 38) {
              s5 = peg$c53;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e55); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseequality_relational_expression();
                if (s7 !== peg$FAILED) {
                  s3 = [ s5, s7 ];
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f81(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseequality_relational_expression();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseequality_relational_expression() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key = peg$currPos * 105 + 59;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parserelative_relational_expression();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c54) {
          s5 = peg$c54;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e56); }
        }
        if (s5 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c55) {
            s5 = peg$c55;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e57); }
          }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parserelative_relational_expression();
            if (s7 !== peg$FAILED) {
              s3 = [ s5, s7 ];
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c54) {
              s5 = peg$c54;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e56); }
            }
            if (s5 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c55) {
                s5 = peg$c55;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e57); }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parserelative_relational_expression();
                if (s7 !== peg$FAILED) {
                  s3 = [ s5, s7 ];
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f82(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parserelative_relational_expression();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parserelative_relational_expression() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key = peg$currPos * 105 + 60;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsebitwise_shift_expression();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c56) {
          s5 = peg$c56;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e58); }
        }
        if (s5 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c57) {
            s5 = peg$c57;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e59); }
          }
          if (s5 === peg$FAILED) {
            s5 = input.charAt(peg$currPos);
            if (peg$r0.test(s5)) {
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e60); }
            }
          }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsebitwise_shift_expression();
            if (s7 !== peg$FAILED) {
              s3 = [ s5, s7 ];
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c56) {
              s5 = peg$c56;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e58); }
            }
            if (s5 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c57) {
                s5 = peg$c57;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e59); }
              }
              if (s5 === peg$FAILED) {
                s5 = input.charAt(peg$currPos);
                if (peg$r0.test(s5)) {
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$e60); }
                }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsebitwise_shift_expression();
                if (s7 !== peg$FAILED) {
                  s3 = [ s5, s7 ];
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f83(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsebitwise_shift_expression();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsebitwise_shift_expression() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key = peg$currPos * 105 + 61;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseadd_subtract_expression();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c58) {
          s5 = peg$c58;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e61); }
        }
        if (s5 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c59) {
            s5 = peg$c59;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e62); }
          }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseadd_subtract_expression();
            if (s7 !== peg$FAILED) {
              s3 = [ s5, s7 ];
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c58) {
              s5 = peg$c58;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e61); }
            }
            if (s5 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c59) {
                s5 = peg$c59;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e62); }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseadd_subtract_expression();
                if (s7 !== peg$FAILED) {
                  s3 = [ s5, s7 ];
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f84(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseadd_subtract_expression();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseadd_subtract_expression() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key = peg$currPos * 105 + 62;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsemultiply_divide_expression();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        s5 = input.charAt(peg$currPos);
        if (peg$r1.test(s5)) {
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e63); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsemultiply_divide_expression();
            if (s7 !== peg$FAILED) {
              s3 = [ s5, s7 ];
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = input.charAt(peg$currPos);
            if (peg$r1.test(s5)) {
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e63); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsemultiply_divide_expression();
                if (s7 !== peg$FAILED) {
                  s3 = [ s5, s7 ];
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f85(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsemultiply_divide_expression();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsemultiply_divide_expression() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key = peg$currPos * 105 + 63;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseunary_expression();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        s5 = input.charAt(peg$currPos);
        if (peg$r2.test(s5)) {
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e64); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseunary_expression();
            if (s7 !== peg$FAILED) {
              s3 = [ s5, s7 ];
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = input.charAt(peg$currPos);
            if (peg$r2.test(s5)) {
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e64); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseunary_expression();
                if (s7 !== peg$FAILED) {
                  s3 = [ s5, s7 ];
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f86(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseunary_expression();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseunary_expression() {
    var s0, s1, s2, s3, s4;

    var key = peg$currPos * 105 + 64;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    s3 = peg$parseprefix_operation();
    if (s3 !== peg$FAILED) {
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$parseprefix_operation();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsepostfix_expression();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f87(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsepostfix_expression();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseprefix_operation() {
    var s0, s1;

    var key = peg$currPos * 105 + 65;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c60) {
      s1 = peg$c60;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e65); }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c61) {
        s1 = peg$c61;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e66); }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f88(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = input.charAt(peg$currPos);
      if (peg$r3.test(s1)) {
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e67); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f89(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 42) {
          s1 = peg$c33;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e35); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f90(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 38) {
            s1 = peg$c53;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e55); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f91();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 6) === peg$c62) {
              s1 = peg$c62;
              peg$currPos += 6;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e68); }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f92();
            }
            s0 = s1;
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsepostfix_expression() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 66;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseprimary_expression();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        s5 = peg$parsepostfix_operation();
        if (s5 !== peg$FAILED) {
          s3 = s5;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsepostfix_operation();
            if (s5 !== peg$FAILED) {
              s3 = s5;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f93(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseprimary_expression();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsepostfix_operation() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 67;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c60) {
      s1 = peg$c60;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e65); }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c61) {
        s1 = peg$c61;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e66); }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f94(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c9;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e11); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsefunction_argument_list();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c10;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e12); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f95(s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c9;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e11); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s3 = peg$c10;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e12); }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f96();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c34;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e36); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseexpression();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s5 = peg$c35;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e37); }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f97(s3);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
              s1 = peg$c63;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e69); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseidentifier();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f98(s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c64) {
                s1 = peg$c64;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e70); }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parseidentifier();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f99(s3);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsefunction_argument_list() {
    var s0, s1, s2, s3, s4, s5, s6;

    var key = peg$currPos * 105 + 68;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseassignment_expression();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c31;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e33); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s4 = [s4, s5, s6];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s3 = peg$parseassignment_expression();
        if (s3 === peg$FAILED) {
          peg$currPos = s2;
          s2 = peg$FAILED;
        } else {
          s2 = s3;
        }
      } else {
        s2 = s3;
      }
    }
    if (s1.length < 1) {
      peg$currPos = s0;
      s0 = peg$FAILED;
    } else {
      s0 = s1;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseprimary_expression() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    var key = peg$currPos * 105 + 69;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6) === peg$c62) {
      s1 = peg$c62;
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e68); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 40) {
          s3 = peg$c9;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e11); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsetype_name();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s7 = peg$c10;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$e12); }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f100(s5);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseidentifier();
      if (s1 !== peg$FAILED) {
        peg$savedPos = peg$currPos;
        s2 = peg$f101(s1);
        if (s2) {
          s2 = peg$FAILED;
        } else {
          s2 = undefined;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f102(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseconstant();
        if (s0 === peg$FAILED) {
          s0 = peg$parsestring_literal();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
              s1 = peg$c9;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e11); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseexpression();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_();
                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s5 = peg$c10;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$e12); }
                    }
                    if (s5 !== peg$FAILED) {
                      s0 = s3;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsetype_name() {
    var s0, s1, s2, s3, s4;

    var key = peg$currPos * 105 + 70;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsespecifier_qualifier_list();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parse_();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseabstract_declarator();
        if (s4 !== peg$FAILED) {
          s2 = s4;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f103(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsesource_character_set() {
    var s0;

    var key = peg$currPos * 105 + 71;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = input.charAt(peg$currPos);
    if (peg$r4.test(s0)) {
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e71); }
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseextended_source_character_set();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseextended_source_character_set() {
    var s0;

    var key = peg$currPos * 105 + 72;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    if (input.charCodeAt(peg$currPos) === 64) {
      s0 = peg$c65;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e72); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsetoken() {
    var s0;

    var key = peg$currPos * 105 + 73;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$parseinclude();
    if (s0 === peg$FAILED) {
      s0 = peg$parsekeyword();
      if (s0 === peg$FAILED) {
        s0 = peg$parseidentifier();
        if (s0 === peg$FAILED) {
          s0 = peg$parseconstant();
          if (s0 === peg$FAILED) {
            s0 = peg$parsestring_literal();
            if (s0 === peg$FAILED) {
              s0 = peg$parsepunctuator();
            }
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseinclude() {
    var s0, s1, s2, s3;

    var key = peg$currPos * 105 + 74;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 10) === peg$c66) {
      s1 = peg$c66;
      peg$currPos += 10;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e73); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseidentifier();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 62) {
          s3 = peg$c67;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e74); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f104(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsekeyword() {
    var s0;

    var key = peg$currPos * 105 + 75;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    if (input.substr(peg$currPos, 14) === peg$c68) {
      s0 = peg$c68;
      peg$currPos += 14;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e75); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 13) === peg$c69) {
        s0 = peg$c69;
        peg$currPos += 13;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e76); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 10) === peg$c70) {
          s0 = peg$c70;
          peg$currPos += 10;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e77); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 9) === peg$c71) {
            s0 = peg$c71;
            peg$currPos += 9;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e78); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 8) === peg$c6) {
              s0 = peg$c6;
              peg$currPos += 8;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e8); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 8) === peg$c72) {
                s0 = peg$c72;
                peg$currPos += 8;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e79); }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c73) {
                  s0 = peg$c73;
                  peg$currPos += 8;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$e80); }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 8) === peg$c30) {
                    s0 = peg$c30;
                    peg$currPos += 8;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e32); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 8) === peg$c74) {
                      s0 = peg$c74;
                      peg$currPos += 8;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$e81); }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 8) === peg$c75) {
                        s0 = peg$c75;
                        peg$currPos += 8;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$e82); }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 8) === peg$c76) {
                          s0 = peg$c76;
                          peg$currPos += 8;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$e83); }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 8) === peg$c77) {
                            s0 = peg$c77;
                            peg$currPos += 8;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$e84); }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c78) {
                              s0 = peg$c78;
                              peg$currPos += 8;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$e85); }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 7) === peg$c15) {
                                s0 = peg$c15;
                                peg$currPos += 7;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$e17); }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 7) === peg$c21) {
                                  s0 = peg$c21;
                                  peg$currPos += 7;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$e23); }
                                }
                                if (s0 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 7) === peg$c79) {
                                    s0 = peg$c79;
                                    peg$currPos += 7;
                                  } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$e86); }
                                  }
                                  if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 6) === peg$c80) {
                                      s0 = peg$c80;
                                      peg$currPos += 6;
                                    } else {
                                      s0 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$e87); }
                                    }
                                    if (s0 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 6) === peg$c81) {
                                        s0 = peg$c81;
                                        peg$currPos += 6;
                                      } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) { peg$fail(peg$e88); }
                                      }
                                      if (s0 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 6) === peg$c26) {
                                          s0 = peg$c26;
                                          peg$currPos += 6;
                                        } else {
                                          s0 = peg$FAILED;
                                          if (peg$silentFails === 0) { peg$fail(peg$e28); }
                                        }
                                        if (s0 === peg$FAILED) {
                                          if (input.substr(peg$currPos, 6) === peg$c3) {
                                            s0 = peg$c3;
                                            peg$currPos += 6;
                                          } else {
                                            s0 = peg$FAILED;
                                            if (peg$silentFails === 0) { peg$fail(peg$e5); }
                                          }
                                          if (s0 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 6) === peg$c29) {
                                              s0 = peg$c29;
                                              peg$currPos += 6;
                                            } else {
                                              s0 = peg$FAILED;
                                              if (peg$silentFails === 0) { peg$fail(peg$e31); }
                                            }
                                            if (s0 === peg$FAILED) {
                                              if (input.substr(peg$currPos, 6) === peg$c62) {
                                                s0 = peg$c62;
                                                peg$currPos += 6;
                                              } else {
                                                s0 = peg$FAILED;
                                                if (peg$silentFails === 0) { peg$fail(peg$e68); }
                                              }
                                              if (s0 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 6) === peg$c20) {
                                                  s0 = peg$c20;
                                                  peg$currPos += 6;
                                                } else {
                                                  s0 = peg$FAILED;
                                                  if (peg$silentFails === 0) { peg$fail(peg$e22); }
                                                }
                                                if (s0 === peg$FAILED) {
                                                  if (input.substr(peg$currPos, 6) === peg$c36) {
                                                    s0 = peg$c36;
                                                    peg$currPos += 6;
                                                  } else {
                                                    s0 = peg$FAILED;
                                                    if (peg$silentFails === 0) { peg$fail(peg$e38); }
                                                  }
                                                  if (s0 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 6) === peg$c14) {
                                                      s0 = peg$c14;
                                                      peg$currPos += 6;
                                                    } else {
                                                      s0 = peg$FAILED;
                                                      if (peg$silentFails === 0) { peg$fail(peg$e16); }
                                                    }
                                                    if (s0 === peg$FAILED) {
                                                      if (input.substr(peg$currPos, 5) === peg$c5) {
                                                        s0 = peg$c5;
                                                        peg$currPos += 5;
                                                      } else {
                                                        s0 = peg$FAILED;
                                                        if (peg$silentFails === 0) { peg$fail(peg$e7); }
                                                      }
                                                      if (s0 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 5) === peg$c25) {
                                                          s0 = peg$c25;
                                                          peg$currPos += 5;
                                                        } else {
                                                          s0 = peg$FAILED;
                                                          if (peg$silentFails === 0) { peg$fail(peg$e27); }
                                                        }
                                                        if (s0 === peg$FAILED) {
                                                          if (input.substr(peg$currPos, 5) === peg$c18) {
                                                            s0 = peg$c18;
                                                            peg$currPos += 5;
                                                          } else {
                                                            s0 = peg$FAILED;
                                                            if (peg$silentFails === 0) { peg$fail(peg$e20); }
                                                          }
                                                          if (s0 === peg$FAILED) {
                                                            if (input.substr(peg$currPos, 5) === peg$c28) {
                                                              s0 = peg$c28;
                                                              peg$currPos += 5;
                                                            } else {
                                                              s0 = peg$FAILED;
                                                              if (peg$silentFails === 0) { peg$fail(peg$e30); }
                                                            }
                                                            if (s0 === peg$FAILED) {
                                                              if (input.substr(peg$currPos, 5) === peg$c82) {
                                                                s0 = peg$c82;
                                                                peg$currPos += 5;
                                                              } else {
                                                                s0 = peg$FAILED;
                                                                if (peg$silentFails === 0) { peg$fail(peg$e89); }
                                                              }
                                                              if (s0 === peg$FAILED) {
                                                                if (input.substr(peg$currPos, 5) === peg$c8) {
                                                                  s0 = peg$c8;
                                                                  peg$currPos += 5;
                                                                } else {
                                                                  s0 = peg$FAILED;
                                                                  if (peg$silentFails === 0) { peg$fail(peg$e10); }
                                                                }
                                                                if (s0 === peg$FAILED) {
                                                                  if (input.substr(peg$currPos, 5) === peg$c83) {
                                                                    s0 = peg$c83;
                                                                    peg$currPos += 5;
                                                                  } else {
                                                                    s0 = peg$FAILED;
                                                                    if (peg$silentFails === 0) { peg$fail(peg$e90); }
                                                                  }
                                                                  if (s0 === peg$FAILED) {
                                                                    if (input.substr(peg$currPos, 4) === peg$c19) {
                                                                      s0 = peg$c19;
                                                                      peg$currPos += 4;
                                                                    } else {
                                                                      s0 = peg$FAILED;
                                                                      if (peg$silentFails === 0) { peg$fail(peg$e21); }
                                                                    }
                                                                    if (s0 === peg$FAILED) {
                                                                      if (input.substr(peg$currPos, 4) === peg$c17) {
                                                                        s0 = peg$c17;
                                                                        peg$currPos += 4;
                                                                      } else {
                                                                        s0 = peg$FAILED;
                                                                        if (peg$silentFails === 0) { peg$fail(peg$e19); }
                                                                      }
                                                                      if (s0 === peg$FAILED) {
                                                                        if (input.substr(peg$currPos, 4) === peg$c23) {
                                                                          s0 = peg$c23;
                                                                          peg$currPos += 4;
                                                                        } else {
                                                                          s0 = peg$FAILED;
                                                                          if (peg$silentFails === 0) { peg$fail(peg$e25); }
                                                                        }
                                                                        if (s0 === peg$FAILED) {
                                                                          if (input.substr(peg$currPos, 4) === peg$c84) {
                                                                            s0 = peg$c84;
                                                                            peg$currPos += 4;
                                                                          } else {
                                                                            s0 = peg$FAILED;
                                                                            if (peg$silentFails === 0) { peg$fail(peg$e91); }
                                                                          }
                                                                          if (s0 === peg$FAILED) {
                                                                            if (input.substr(peg$currPos, 4) === peg$c27) {
                                                                              s0 = peg$c27;
                                                                              peg$currPos += 4;
                                                                            } else {
                                                                              s0 = peg$FAILED;
                                                                              if (peg$silentFails === 0) { peg$fail(peg$e29); }
                                                                            }
                                                                            if (s0 === peg$FAILED) {
                                                                              if (input.substr(peg$currPos, 4) === peg$c13) {
                                                                                s0 = peg$c13;
                                                                                peg$currPos += 4;
                                                                              } else {
                                                                                s0 = peg$FAILED;
                                                                                if (peg$silentFails === 0) { peg$fail(peg$e15); }
                                                                              }
                                                                              if (s0 === peg$FAILED) {
                                                                                if (input.substr(peg$currPos, 4) === peg$c37) {
                                                                                  s0 = peg$c37;
                                                                                  peg$currPos += 4;
                                                                                } else {
                                                                                  s0 = peg$FAILED;
                                                                                  if (peg$silentFails === 0) { peg$fail(peg$e39); }
                                                                                }
                                                                                if (s0 === peg$FAILED) {
                                                                                  if (input.substr(peg$currPos, 4) === peg$c22) {
                                                                                    s0 = peg$c22;
                                                                                    peg$currPos += 4;
                                                                                  } else {
                                                                                    s0 = peg$FAILED;
                                                                                    if (peg$silentFails === 0) { peg$fail(peg$e24); }
                                                                                  }
                                                                                  if (s0 === peg$FAILED) {
                                                                                    if (input.substr(peg$currPos, 3) === peg$c11) {
                                                                                      s0 = peg$c11;
                                                                                      peg$currPos += 3;
                                                                                    } else {
                                                                                      s0 = peg$FAILED;
                                                                                      if (peg$silentFails === 0) { peg$fail(peg$e13); }
                                                                                    }
                                                                                    if (s0 === peg$FAILED) {
                                                                                      if (input.substr(peg$currPos, 3) === peg$c24) {
                                                                                        s0 = peg$c24;
                                                                                        peg$currPos += 3;
                                                                                      } else {
                                                                                        s0 = peg$FAILED;
                                                                                        if (peg$silentFails === 0) { peg$fail(peg$e26); }
                                                                                      }
                                                                                      if (s0 === peg$FAILED) {
                                                                                        if (input.substr(peg$currPos, 2) === peg$c12) {
                                                                                          s0 = peg$c12;
                                                                                          peg$currPos += 2;
                                                                                        } else {
                                                                                          s0 = peg$FAILED;
                                                                                          if (peg$silentFails === 0) { peg$fail(peg$e14); }
                                                                                        }
                                                                                        if (s0 === peg$FAILED) {
                                                                                          if (input.substr(peg$currPos, 2) === peg$c7) {
                                                                                            s0 = peg$c7;
                                                                                            peg$currPos += 2;
                                                                                          } else {
                                                                                            s0 = peg$FAILED;
                                                                                            if (peg$silentFails === 0) { peg$fail(peg$e9); }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseidentifier() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 76;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$currPos;
    s3 = input.charAt(peg$currPos);
    if (peg$r5.test(s3)) {
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e92); }
    }
    if (s3 !== peg$FAILED) {
      s4 = [];
      s5 = input.charAt(peg$currPos);
      if (peg$r6.test(s5)) {
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e93); }
      }
      while (s5 !== peg$FAILED) {
        s4.push(s5);
        s5 = input.charAt(peg$currPos);
        if (peg$r6.test(s5)) {
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e93); }
        }
      }
      s3 = [s3, s4];
      s2 = s3;
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      s1 = input.substring(s1, peg$currPos);
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$f105(s1);
      if (s2) {
        s2 = undefined;
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f106(s1);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseconstant() {
    var s0;

    var key = peg$currPos * 105 + 77;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$parsedecimal_floating_constant();
    if (s0 === peg$FAILED) {
      s0 = peg$parseinteger_constant();
      if (s0 === peg$FAILED) {
        s0 = peg$parseenumeration_constant();
        if (s0 === peg$FAILED) {
          s0 = peg$parsecharacter_constant();
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseinteger_constant() {
    var s0, s1, s2, s3;

    var key = peg$currPos * 105 + 78;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parsedecimal_constant();
    if (s2 !== peg$FAILED) {
      s1 = input.substring(s1, peg$currPos);
    } else {
      s1 = s2;
    }
    if (s1 === peg$FAILED) {
      s1 = peg$parseoctal_constant();
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        s2 = peg$parsehexadecimal_constant();
        if (s2 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s2;
        }
        if (s1 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 48) {
            s1 = peg$c85;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e94); }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parseinteger_suffix();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s2 = input.substring(s2, peg$currPos);
      peg$savedPos = s0;
      s0 = peg$f107(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsedecimal_constant() {
    var s0, s1, s2, s3;

    var key = peg$currPos * 105 + 79;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsenonzero_digit();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsedigit();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsedigit();
      }
      s1 = [s1, s2];
      s0 = s1;
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsenonzero_digit() {
    var s0;

    var key = peg$currPos * 105 + 80;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = input.charAt(peg$currPos);
    if (peg$r7.test(s0)) {
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e95); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsedigit() {
    var s0;

    var key = peg$currPos * 105 + 81;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = input.charAt(peg$currPos);
    if (peg$r8.test(s0)) {
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e96); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseoctal_constant() {
    var s0, s1, s2, s3, s4;

    var key = peg$currPos * 105 + 82;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 48) {
      s1 = peg$c85;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e94); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = [];
      s4 = peg$parseoctal_digit();
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseoctal_digit();
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f108(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseoctal_digit() {
    var s0;

    var key = peg$currPos * 105 + 83;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = input.charAt(peg$currPos);
    if (peg$r9.test(s0)) {
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e97); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsehexadecimal_constant() {
    var s0, s1, s2, s3;

    var key = peg$currPos * 105 + 84;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parsehexadecimal_prefix();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsehexadecimal_digit();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsehexadecimal_digit();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsehexadecimal_prefix() {
    var s0;

    var key = peg$currPos * 105 + 85;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    if (input.substr(peg$currPos, 2) === peg$c86) {
      s0 = peg$c86;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e98); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c87) {
        s0 = peg$c87;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e99); }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsehexadecimal_digit() {
    var s0;

    var key = peg$currPos * 105 + 86;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = input.charAt(peg$currPos);
    if (peg$r10.test(s0)) {
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e100); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseinteger_suffix() {
    var s0, s1, s2;

    var key = peg$currPos * 105 + 87;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseunsigned_suffix();
    if (s1 !== peg$FAILED) {
      s2 = peg$parselong_long_suffix();
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseunsigned_suffix();
      if (s1 !== peg$FAILED) {
        s2 = peg$parselong_suffix();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parselong_long_suffix();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseunsigned_suffix();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parselong_suffix();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseunsigned_suffix();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseunsigned_suffix() {
    var s0;

    var key = peg$currPos * 105 + 88;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = input.charAt(peg$currPos);
    if (peg$r11.test(s0)) {
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e101); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parselong_suffix() {
    var s0;

    var key = peg$currPos * 105 + 89;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = input.charAt(peg$currPos);
    if (peg$r12.test(s0)) {
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e102); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parselong_long_suffix() {
    var s0;

    var key = peg$currPos * 105 + 90;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    if (input.substr(peg$currPos, 2) === peg$c88) {
      s0 = peg$c88;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e103); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c89) {
        s0 = peg$c89;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e104); }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsedecimal_floating_constant() {
    var s0, s1, s2, s3, s4;

    var key = peg$currPos * 105 + 91;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$currPos;
    s3 = peg$parsefractional_constant();
    if (s3 !== peg$FAILED) {
      s4 = peg$parseexponent_part();
      if (s4 === peg$FAILED) {
        s4 = null;
      }
      s3 = [s3, s4];
      s2 = s3;
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      s1 = input.substring(s1, peg$currPos);
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parsefloating_suffix();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s2 = input.substring(s2, peg$currPos);
      peg$savedPos = s0;
      s0 = peg$f109(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      s3 = [];
      s4 = peg$parsedigit();
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsedigit();
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parseexponent_part();
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsefloating_suffix();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f110(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsefractional_constant() {
    var s0, s1, s2, s3, s4;

    var key = peg$currPos * 105 + 92;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsedigit();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parsedigit();
    }
    if (input.charCodeAt(peg$currPos) === 46) {
      s2 = peg$c63;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e69); }
    }
    if (s2 !== peg$FAILED) {
      s3 = [];
      s4 = peg$parsedigit();
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsedigit();
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s1 = [s1, s2, s3];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsedigit();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsedigit();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s2 = peg$c63;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e69); }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseexponent_part() {
    var s0, s1, s2, s3, s4;

    var key = peg$currPos * 105 + 93;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = input.charAt(peg$currPos);
    if (peg$r13.test(s1)) {
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e105); }
    }
    if (s1 !== peg$FAILED) {
      s2 = input.charAt(peg$currPos);
      if (peg$r1.test(s2)) {
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e63); }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = [];
      s4 = peg$parsedigit();
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsedigit();
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s1 = [s1, s2, s3];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsefloating_suffix() {
    var s0;

    var key = peg$currPos * 105 + 94;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = input.charAt(peg$currPos);
    if (peg$r14.test(s0)) {
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e106); }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseenumeration_constant() {
    var s0, s1, s2;

    var key = peg$currPos * 105 + 95;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = peg$parseidentifier();
    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$f111(s1);
      if (s2) {
        s2 = peg$FAILED;
      } else {
        s2 = undefined;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f112(s1);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsecharacter_constant() {
    var s0, s1, s2, s3;

    var key = peg$currPos * 105 + 96;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 39) {
      s1 = peg$c90;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e107); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsec_char();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 39) {
          s3 = peg$c90;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e107); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f113(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsec_char() {
    var s0, s1;

    var key = peg$currPos * 105 + 97;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = input.charAt(peg$currPos);
    if (peg$r15.test(s1)) {
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e108); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f114(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseextended_source_character_set();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f115(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$parseescape_sequence();
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseescape_sequence() {
    var s0;

    var key = peg$currPos * 105 + 98;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$parsesimple_escape_sequence();
    if (s0 === peg$FAILED) {
      s0 = peg$parseoctal_escape_sequence();
      if (s0 === peg$FAILED) {
        s0 = peg$parsehexadecimal_escape_sequence();
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsesimple_escape_sequence() {
    var s0, s1;

    var key = peg$currPos * 105 + 99;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c91) {
      s1 = peg$c91;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e109); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f116();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c92) {
        s1 = peg$c92;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e110); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f117();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c93) {
          s1 = peg$c93;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e111); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f118();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c94) {
            s1 = peg$c94;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e112); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f119();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c95) {
              s1 = peg$c95;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e113); }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f120();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c96) {
                s1 = peg$c96;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e114); }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f121();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c97) {
                  s1 = peg$c97;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$e115); }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$f122();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c98) {
                    s1 = peg$c98;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e116); }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$f123();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c99) {
                      s1 = peg$c99;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$e117); }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$f124();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c100) {
                        s1 = peg$c100;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$e118); }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$f125();
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 2) === peg$c101) {
                          s1 = peg$c101;
                          peg$currPos += 2;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$e119); }
                        }
                        if (s1 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$f126();
                        }
                        s0 = s1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parseoctal_escape_sequence() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 100;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 92) {
      s1 = peg$c102;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e120); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$currPos;
      s4 = [];
      s5 = peg$parseoctal_digit();
      while (s5 !== peg$FAILED) {
        s4.push(s5);
        if (s4.length >= 3) {
          s5 = peg$FAILED;
        } else {
          s5 = peg$parseoctal_digit();
        }
      }
      if (s4.length < 1) {
        peg$currPos = s3;
        s3 = peg$FAILED;
      } else {
        s3 = s4;
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f127(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsehexadecimal_escape_sequence() {
    var s0, s1, s2, s3, s4, s5;

    var key = peg$currPos * 105 + 101;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c103) {
      s1 = peg$c103;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e121); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$currPos;
      s4 = [];
      s5 = peg$parsehexadecimal_digit();
      while (s5 !== peg$FAILED) {
        s4.push(s5);
        if (s4.length >= 2) {
          s5 = peg$FAILED;
        } else {
          s5 = peg$parsehexadecimal_digit();
        }
      }
      if (s4.length < 1) {
        peg$currPos = s3;
        s3 = peg$FAILED;
      } else {
        s3 = s4;
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f128(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsestring_literal() {
    var s0, s1, s2, s3;

    var key = peg$currPos * 105 + 102;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c104;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e122); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parses_char();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parses_char();
      }
      if (input.charCodeAt(peg$currPos) === 34) {
        s3 = peg$c104;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e122); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f129(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parses_char() {
    var s0, s1;

    var key = peg$currPos * 105 + 103;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    s0 = peg$currPos;
    s1 = input.charAt(peg$currPos);
    if (peg$r16.test(s1)) {
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e123); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f130(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$parseescape_sequence();
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }

  function peg$parsepunctuator() {
    var s0;

    var key = peg$currPos * 105 + 104;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

      return cached.result;
    }

    if (input.substr(peg$currPos, 4) === peg$c105) {
      s0 = peg$c105;
      peg$currPos += 4;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e124); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 3) === peg$c106) {
        s0 = peg$c106;
        peg$currPos += 3;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e125); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c43) {
          s0 = peg$c43;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e45); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c44) {
            s0 = peg$c44;
            peg$currPos += 3;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e46); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c60) {
              s0 = peg$c60;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e65); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c61) {
                s0 = peg$c61;
                peg$currPos += 2;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e66); }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c38) {
                  s0 = peg$c38;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$e40); }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c39) {
                    s0 = peg$c39;
                    peg$currPos += 2;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e41); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c40) {
                      s0 = peg$c40;
                      peg$currPos += 2;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$e42); }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c41) {
                        s0 = peg$c41;
                        peg$currPos += 2;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$e43); }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c42) {
                          s0 = peg$c42;
                          peg$currPos += 2;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$e44); }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c45) {
                            s0 = peg$c45;
                            peg$currPos += 2;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$e47); }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c46) {
                              s0 = peg$c46;
                              peg$currPos += 2;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$e48); }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 2) === peg$c47) {
                                s0 = peg$c47;
                                peg$currPos += 2;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$e49); }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c55) {
                                  s0 = peg$c55;
                                  peg$currPos += 2;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$e57); }
                                }
                                if (s0 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 2) === peg$c54) {
                                    s0 = peg$c54;
                                    peg$currPos += 2;
                                  } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$e56); }
                                  }
                                  if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 2) === peg$c56) {
                                      s0 = peg$c56;
                                      peg$currPos += 2;
                                    } else {
                                      s0 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$e58); }
                                    }
                                    if (s0 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 2) === peg$c57) {
                                        s0 = peg$c57;
                                        peg$currPos += 2;
                                      } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) { peg$fail(peg$e59); }
                                      }
                                      if (s0 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 2) === peg$c59) {
                                          s0 = peg$c59;
                                          peg$currPos += 2;
                                        } else {
                                          s0 = peg$FAILED;
                                          if (peg$silentFails === 0) { peg$fail(peg$e62); }
                                        }
                                        if (s0 === peg$FAILED) {
                                          if (input.substr(peg$currPos, 2) === peg$c58) {
                                            s0 = peg$c58;
                                            peg$currPos += 2;
                                          } else {
                                            s0 = peg$FAILED;
                                            if (peg$silentFails === 0) { peg$fail(peg$e61); }
                                          }
                                          if (s0 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 2) === peg$c64) {
                                              s0 = peg$c64;
                                              peg$currPos += 2;
                                            } else {
                                              s0 = peg$FAILED;
                                              if (peg$silentFails === 0) { peg$fail(peg$e70); }
                                            }
                                            if (s0 === peg$FAILED) {
                                              if (input.substr(peg$currPos, 2) === peg$c50) {
                                                s0 = peg$c50;
                                                peg$currPos += 2;
                                              } else {
                                                s0 = peg$FAILED;
                                                if (peg$silentFails === 0) { peg$fail(peg$e52); }
                                              }
                                              if (s0 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 2) === peg$c49) {
                                                  s0 = peg$c49;
                                                  peg$currPos += 2;
                                                } else {
                                                  s0 = peg$FAILED;
                                                  if (peg$silentFails === 0) { peg$fail(peg$e51); }
                                                }
                                                if (s0 === peg$FAILED) {
                                                  if (input.substr(peg$currPos, 2) === peg$c107) {
                                                    s0 = peg$c107;
                                                    peg$currPos += 2;
                                                  } else {
                                                    s0 = peg$FAILED;
                                                    if (peg$silentFails === 0) { peg$fail(peg$e126); }
                                                  }
                                                  if (s0 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 2) === peg$c108) {
                                                      s0 = peg$c108;
                                                      peg$currPos += 2;
                                                    } else {
                                                      s0 = peg$FAILED;
                                                      if (peg$silentFails === 0) { peg$fail(peg$e127); }
                                                    }
                                                    if (s0 === peg$FAILED) {
                                                      if (input.substr(peg$currPos, 2) === peg$c109) {
                                                        s0 = peg$c109;
                                                        peg$currPos += 2;
                                                      } else {
                                                        s0 = peg$FAILED;
                                                        if (peg$silentFails === 0) { peg$fail(peg$e128); }
                                                      }
                                                      if (s0 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 2) === peg$c110) {
                                                          s0 = peg$c110;
                                                          peg$currPos += 2;
                                                        } else {
                                                          s0 = peg$FAILED;
                                                          if (peg$silentFails === 0) { peg$fail(peg$e129); }
                                                        }
                                                        if (s0 === peg$FAILED) {
                                                          if (input.substr(peg$currPos, 2) === peg$c111) {
                                                            s0 = peg$c111;
                                                            peg$currPos += 2;
                                                          } else {
                                                            s0 = peg$FAILED;
                                                            if (peg$silentFails === 0) { peg$fail(peg$e130); }
                                                          }
                                                          if (s0 === peg$FAILED) {
                                                            if (input.substr(peg$currPos, 2) === peg$c112) {
                                                              s0 = peg$c112;
                                                              peg$currPos += 2;
                                                            } else {
                                                              s0 = peg$FAILED;
                                                              if (peg$silentFails === 0) { peg$fail(peg$e131); }
                                                            }
                                                            if (s0 === peg$FAILED) {
                                                              s0 = input.charAt(peg$currPos);
                                                              if (peg$r17.test(s0)) {
                                                                peg$currPos++;
                                                              } else {
                                                                s0 = peg$FAILED;
                                                                if (peg$silentFails === 0) { peg$fail(peg$e132); }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

    return s0;
  }


  const thisParser = this; // reference to the parser object itself (to get some variables)

  function getCurrPosition() {
    const loc = range();
    return {
      start: thisParser.tokenPositions.get(loc.start).start,
      end: thisParser.tokenPositions.get(Math.max(loc.start, loc.end - 1)).end
    }
  }
  
  function throwErrorWithLocation(message) {
    const e = new Error(message);
    e.location = location();
    throw e;
  }

  /**
   * Helper function to create and return a Node with position and type information
   */
  function generateNode(type, data) {
    return {
      type: type,
      position: getCurrPosition(),
      ...data,
    };
  }

  const C_Keywords = new Set([
    "auto",
    "extern",
    "break",
    "float",
    "case",
    "for",
    "char",
    "goto",
    "const",
    "if",
    "continue",
    "inline",
    "default",
    "int",
    "do",
    "long",
    "double",
    "register",
    "else",
    "restrict",
    "enum",
    "return",
    "short",
    "signed",
    "sizeof",
    "static",
    "struct",
    "switch",
    "typedef",
    "union",
    "unsigned",
    "void",
    "volatile",
    "while",
    "_Alignas",
    "_Alignof",
    "_Atomic",
    "_Bool",
    "_Complex",
    "_Generic",
    "_Imaginary",
    "_Noreturn",
    "_Static_assert",
    "_Thread_local",
  ]);

  const warnings = [];
  // add a warning to warnings
  function warn(message) {
    warnings.push({ message, position: getCurrPosition() });
  }

  // any non-syntax related compilation errors detected during parsing
  const compilationErrors = [];
  function error(message) {
    compilationErrors.push({ message, position: getCurrPosition() });
  }

  // this object is used to keep track of symbols, and identify whether they represent a variable/function or type (defined by struct/enum/typedef)
  // this is critical for identifying if an identifier is a typename defined by typedef or a variable -> needed for resolving "typedef ambiguity"
  // it is also used for resolving pointers to incomplete types (pointing to structs that are not yet defined)
  let symbolTable = {
    // 2 separate namespaces as per 6.2.3 of C17 standard
    identifiers: {}, // namespace for identifiers (regular variables/functions and types) // a symbol entry is defined as such: { type: "type" | "variable", dataType: DataType }
    tags: {}, // namespace for struct/enum tags // a symbol entry is defined as such: { type: "enum" | "struct", dataType: DataType }
  };

  function addIdentifierToSymbolTable(name, symbolEntry) {
    if (name in symbolTable.identifiers) {
      symbolTable.identifiers[name].push(symbolEntry);
    } else {
      symbolTable.identifiers[name] = [symbolEntry];
    }
    return { name, symbolEntry }; // returns details of the added symbol, to be removed at end of scope
  }

  function addTagToSymbolTable(name, symbolEntry) {
    if (name in symbolTable.tags) {
      symbolTable.tags[name].push(symbolEntry);
    } else {
      symbolTable.tags[name] = [symbolEntry];
    }
    return { name, symbolEntry }; // returns details of the added symbol, to be removed at end of scope
  }

  function isIdentifierAType(name) {
    if (!(name in symbolTable.identifiers) || symbolTable.identifiers[name].length <= 0) {
      return false;
    }
    const entries = symbolTable.identifiers[name];
    return entries[entries.length - 1].type === "type";
  }

  function isIdentifierDefined(name) {
    return name in symbolTable.identifiers && symbolTable.identifiers[name].length > 0;
  }

  function getIdentifierSymbolEntry(name) {
    if (!(name in symbolTable.identifiers) || symbolTable.identifiers[name].length <= 0) {
      throwErrorWithLocation(`'${name}' not declared`);
    }
    const entries = symbolTable.identifiers[name];
    return entries[entries.length - 1];
  }

  function isTagDefined(name) {
    return name in symbolTable.tags && symbolTable.tags[name].length > 0;
  }

  function getTagSymbolEntry(name) {
    if (!(name in symbolTable.tags) || symbolTable.tags[name].length <= 0) {
      throwErrorWithLocation(`'${name}' not declared`);
    }
    const entries = symbolTable.tags[name];
    return entries[entries.length - 1];
  }

  // pop off the latest symbol entry for a symbol (to be done at end of scopes)
  function removeIdentifierSymbolEntry(name) {
    if (!(name in symbolTable.identifiers) || symbolTable.identifiers[name].length <= 0) {
      throwErrorWithLocation(`'${name}' not declared`);
    }
    symbolTable.identifiers[name].pop();
  }

  function removeTagSymbolEntry(name) {
    if (!(name in symbolTable.tags) || symbolTable.tags[name].length <= 0) {
      throwErrorWithLocation(`'${name}' undeclared`);
    }
    return symbolTable.tags[name].pop();
  }

  /**
   *  Try to resolve the incomplete pointers given. Return whatever is still unresolved.
   */
  function resolveIncompletePointers(incompletePointers) {
    const unresolvedIncompletePointers = [];  
    for (const incompletePointer of incompletePointers) {
      if (isTagDefined(incompletePointer.pointeeType.tag)) {
        // incomplete pointee type was defined - now complete
        incompletePointer.pointeeType = getTagSymbolEntry(
          incompletePointer.pointeeType.tag
        ).dataType;
      } else {
        // incomplete pointee type still not defined
        unresolvedIncompletePointers.push(incompletePointer);
      }
    }
    return unresolvedIncompletePointers
  }

  /**
   * Remove the identifiers and tags that a given declaration created.
   * Also resolves incomplete pointers if the declaration resolves them. (declaration defines an incomplete type that a incomplete pointer points to)
   * Returns any remainig unresolved incomplete pointers.
   * 
   * Also checks for any redeclaration by checking if a given identifier/tag is removed more than once in the scope containing this declaration
   * @param removedTagsInScope object containing the tags that were removed in the scope containg this declaration mapped to the type of tag (struct or enum)
   * @param removedIdentifiersInScope
   */
  function removeDeclarationIdentifiersAndTags(declaration, existingIncompletePointers, removedTagsInScope, removedIdentifiersInScope, isRootScope) {
    let incompletePointers = existingIncompletePointers ?? [];
    if (declaration.incompletePointers) {
      // add the incomplete pointers from the declaration itself
      incompletePointers.push(...(declaration.incompletePointers));
    }

    incompletePointers = resolveIncompletePointers(incompletePointers);

    // remove identifiers
    for (const identifierDefinition of declaration.identifierDefinitions) {
      // check if identifiers were declared before
      if (identifierDefinition.name in removedIdentifiersInScope) {
        if (!(identifierDefinition.symbolEntry.type === "type" && removedIdentifiersInScope[identifierDefinition.name].type === "type") || JSON.stringify(identifierDefinition.symbolEntry.dataType) !== JSON.stringify(removedIdentifiersInScope[identifierDefinition.name].dataType)) {  
          // in all causes, unless the previous declaration was a typedef that declared as the same type, then there is a redeclaration error.
          if (isRootScope) {
            if (identifierDefinition.symbolEntry.type !== "variable" || removedIdentifiersInScope[identifierDefinition.name].type !== "variable" || JSON.stringify(identifierDefinition.symbolEntry.dataType) !== JSON.stringify(removedIdentifiersInScope[identifierDefinition.name].dataType)) {
              // in root scope it is allowed to have the 2 declarations with linkage (object/function) as long as they declare the same type
              error(`redeclaration of '${identifierDefinition.name}' with conflicting type`); 
            }
          } else {
            error(`redeclaration of '${identifierDefinition.name}'`);
          }  
        }
      }
      removedIdentifiersInScope[identifierDefinition.name] = identifierDefinition.symbolEntry;
      removeIdentifierSymbolEntry(identifierDefinition.name);
    }

    // remove tags
    if (declaration.tagDefinitions) {
      for (const tagDefinition of declaration.tagDefinitions) {
        if (tagDefinition.name in removedTagsInScope) {
          if (removedTagsInScope[tagDefinition.name].type === tagDefinition.symbolEntry.type) {
            // redefinition of enum / struct
            error(`redefinition of '${removedTagsInScope[tagDefinition.name].type} ${tagDefinition.name}'`);
          } else {
            if (removedTagsInScope[tagDefinition.name].type !== "incomplete" || removedTagsInScope[tagDefinition.name].subtype !== tagDefinition.symbolEntry.type) {
              // there is only an error is the previous tag was not incomplete or it was incomplete and its declaerd a different type of tag
              error(`redefinition of '${tagDefinition.name}' as wrong kind of tag`)
            }
          }
        }
        removeTagSymbolEntry(tagDefinition.name);
        removedTagsInScope[tagDefinition.name] = tagDefinition.symbolEntry.dataType;
      }
    }

    return incompletePointers;
  }

  function createBlockNode(statements) {
    // remove the declarations that were made in this block from the scope and unpack declarations
    const unpackedBlockStatements = [];
    let unresolvedIncompletePointers = [];
    const removedIdentifiers = {};
    const removedTags = {};
    for (const statement of statements) {
      const { unpackedStatements, incompletePointers } = unpackScopedStatement(statement, unresolvedIncompletePointers, removedTags, removedIdentifiers);
      unpackedBlockStatements.push(...unpackedStatements);
      unresolvedIncompletePointers = incompletePointers;
    }

    return generateNode("Block", {
      statements: unpackedBlockStatements,
      incompletePointers: unresolvedIncompletePointers,
    });
  }

  /**
   * Unpacks statements in a scope (block, switch scope).
   */
  function unpackScopedStatement(statement, unresolvedIncompletePointers, removedTags, removedIdentifiers) {
    const unpackedStatements = [];
    let incompletePointers = unresolvedIncompletePointers;
    if (statement === null) {
      // ignore null statements
    } else if (statement.type === "Declaration") {
      unpackedStatements.push(...(statement.declarations));
      // add any incompletepointers from the declaration
      incompletePointers = removeDeclarationIdentifiersAndTags(
        statement,
        incompletePointers,
        removedTags,
        removedIdentifiers
      );
    } else if (statement.type === "Block" || statement.type === "SwitchStatement") {
      // bring up all the incomplete pointers from the nested block
      incompletePointers.push(...(statement.incompletePointers));
      delete statement.incompletePointers;
      unpackedStatements.push(statement);
    } else {
      unpackedStatements.push(statement);
    }

    return { unpackedStatements, incompletePointers };
  }

  /**
   * Performs similarly to createBlockNode - has to remove any declared symbols 
   * as a new scope is defined in the switch statement block.
   */
  function createSwitchStatementNode(targetExpression, cases, defaultStatements) {
    const switchStatementNode = generateNode("SwitchStatement", {
      targetExpression: targetExpression,
      cases: [],
      defaultStatements: [],
      incompletePointers: []
    });
    const removedTags = {};
    const removedIdentifiers = {};
    for (const switchCase of cases) {
      const switchStatementCase = {
        type: "SwitchStatementCase",
        position: switchCase.position,
        conditionMatch: switchCase.conditionMatch,
        statements: []
      }
      for (const statement of switchCase.statements) {
        const { unpackedStatements, incompletePointers } = unpackScopedStatement(statement, switchStatementNode.incompletePointers, removedTags, removedIdentifiers);
        switchStatementCase.statements.push(...unpackedStatements);
        switchStatementNode.incompletePointers = incompletePointers;
      }
      switchStatementNode.cases.push(switchStatementCase);
    }
    for (const statement of defaultStatements) {
      const { unpackedStatements, incompletePointers } = unpackScopedStatement(statement, switchStatementNode.incompletePointers, removedTags, removedIdentifiers);
      switchStatementNode.defaultStatements.push(...unpackedStatements);
      switchStatementNode.incompletePointers = incompletePointers;
    }

    return switchStatementNode;
  }

  /**
   * Needed to handle ambiguity between identifier and keyword.
   */
  function isStringAKeyword(str) {
    return C_Keywords.has(str);
  }

  /**
   * Create a datatype that represents an incomplete type - a struct/enum that has not yet been defined, but has been referenced in a pointer.
   */
  function createIncompleteDataType(type, name) {
    return {
      type: "incomplete",
      subtype: type,
      tag: name,
    };
  }

  /**
   * Creates the Root node. Since Root node is created at the top of the parse tree, this function is run after the whole proram is parsed.
   * Thus any cleanup/extra logic that requires information which is only completely available after parsing can be done here.
   */
  function createRootNode(children) {
    const unpackedChildren = [];
    let unresolvedIncompletePointers = [];
    const removedTags = {};
    const removedIdentifiers = {};
    for (const child of children) {
      if (child.type === "Declaration") {
        unpackedChildren.push(...child.declarations);
        unresolvedIncompletePointers = removeDeclarationIdentifiersAndTags(
          child,
          unresolvedIncompletePointers,
          removedTags,
          removedIdentifiers,
          true
        );
      } else if (child.type === "FunctionDefinition") {
        if (child.incompletePointers) {
          unresolvedIncompletePointers.push(...(child.incompletePointers));
        }
        delete child.incompletePointers;
        unpackedChildren.push(child);
      } else {
        // shoudlnt happen
        error("Unknown child in root node");
      }
    }
    return generateNode("Root", { children: unpackedChildren });
  }

  function generateIntegerConstant(value, suffix) {
    let correctedSuffix;
    if (suffix.length > 0) {
      correctedSuffix = suffix.toLowerCase();
      if (correctedSuffix.contains("ll")) {
        // in this implementation long long and long are identical
        if (correctedSuffix.contains("u")) {
          correctedSuffix = "ul";
        } else {
          correctedSuffix = "l";
        }
      }
    } else {
      correctedSuffix = null;
    }

    return generateNode("IntegerConstant", {
      value: BigInt(value),
      suffix: correctedSuffix,
    });
  }

  function generateFloatConstant(value, suffix) {
    return generateNode("FloatConstant", {
      value: Number(value),
      suffix: suffix === "f" || suffix === "F" ? "f" : null,
    });
  }

  /**
   * Process declarations that do not have a declarator - i.e they should be declaring a struct/enum type.
   */
  function processDeclarationWithoutDeclarator(declarationSpecifiers) {
    const { enumDeclarations, tagDefinitions, storageClass, incompletePointers, hasTypeDefSpecifier, constPresent, noType } =
      unpackDeclarationSpecifiers(declarationSpecifiers, true);
    const identifierDefinitions = [];
    const declarations = [];
    
    // if no tags (struct or enum) were declared, then this violates 6.7/2 of C17 standard.
    if ((typeof tagDefinitions === "undefined" || tagDefinitions.length === 0)) {
      if (noType) {
        if (constPresent) {
          throwErrorWithLocation("useless type qualifier in empty declaration")
        }
        if (storageClass) {
          throwErrorWithLocation("useless storage class qualifier in empty declaration");
        }
      } else {
        throwErrorWithLocation("empty declaration")
      }
      return generateNode("Declaration", { declarations: [], identifierDefinitions: [] });
    }

    if (storageClass) {
      warn("useless storage class qualifier in empty declaration");
    }

    // add all enum variables that could have been defined in enum specifier
    if (typeof enumDeclarations !== "undefined") {
      enumDeclarations.forEach((enumDeclaration) => {
        enumDeclaration.enumerators.forEach((enumerator) => {
          identifierDefinitions.push(
            addIdentifierToSymbolTable(enumerator.name, {
              type: "variable",
              dataType: createPrimaryDataType("signed int"),
            })
          );
        });

        declarations.push(enumDeclaration);
      });
    }

    return generateNode("Declaration", {
      declarations,
      tagDefinitions,
      identifierDefinitions,
      incompletePointers,
    });
  }

  /**
   * Builds and returns a tree of binary operations which involves the 2 operaands (left and right expressions), and a operator
   * @param firstExpr first expression in the operation expression e.g. "2" in "2 + 3 + 4"
   * @param exprsWithOperatorArr an array of arrays of size 2 which contain an operator in first index and the expr in 2nd index. e.g: [["+", 3], ["+", 4]]
   */
  function createLeftToRightBinaryExpressionTree(
    firstExpr,
    exprsWithOperatorArr
  ) {
    let currNode = firstExpr;
    for (const operation of exprsWithOperatorArr) {
      // create a new operation node
      currNode = generateNode("BinaryExpression", {
        leftExpr: currNode,
        rightExpr: operation[1],
        operator: operation[0],
      });
    }
    return currNode;
  }

  function createUnaryExpressionNode(expr, operator) {
    // special handling for negated constants, just negate the value of constant
    if (
      operator === "-" &&
      (expr.type === "IntegerConstant" || expr.type === "FloatConstant")
    ) {
      return {
        ...expr,
        value: -expr.value,
      };
    }

    return generateNode("UnaryExpression", {
      operator,
      expression: expr,
    });
  }

  // Creates a PrimaryDataType object.
  function createPrimaryDataType(primaryDataType) {
    return {
      type: "primary",
      primaryDataType,
    };
  }

  function createEnumDataType(tag) {
    return {
      type: "enum",
      tag
    }
  }

  function createArrayDataType(elementDataType, numElements) {
    return {
      type: "array",
      elementDataType: elementDataType,
      numElements,
    };
  }

  function createInitializerList(values) {
    values = values ?? [];
    return generateNode("InitializerList", {
      values,
    });
  }

  function createInitializerSingle(value) {
    return generateNode("InitializerSingle", {
      value,
    });
  }

  // Evaluates the string of postfix expressions to generate a complete tree of unary expression nodes
  // Follows left to right associativity.
  function createPostfixExpressionNode(firstExpr, operations) {
    let currNode = firstExpr;
    for (const operation of operations) {
      if (operation.type === "ArrayElementExpr") {
        // array element expr are equivalent to pointer dereference expression A[B] => *(A + B)
        currNode = generateNode("PointerDereference", {
          expr: {
            type: "BinaryExpression",
            leftExpr: currNode,
            rightExpr: operation.index,
            operator: "+",
          },
        });
      } else if (operation.type === "StructPointerMemberAccess") {
        // similar to array element expr, a->x is equivalent to *a.x
        currNode = generateNode("StructMemberAccess", {
          expr: {
            type: "PointerDereference",
            expr: currNode,
          },
          fieldTag: operation.fieldTag,
        });
      } else {
        currNode = {
          ...operation,
          expr: currNode,
        };
      }
    }
    currNode.position = getCurrPosition();
    return currNode;
  }

  // Evaluates the string of prefix expressions to generate a complete tree of unary expression nodes
  // Follows right to left associativity
  // @param firstExpr refers to the rightmost expression
  function createPrefixExpressionNode(firstExpr, operations) {
    let currNode = firstExpr;
    for (let i = operations.length - 1; i >= 0; --i) {
      const { type, ...rest } = operations[i];
      currNode = generateNode(type, {
        ...rest,
        expr: currNode,
      });
    }
    return currNode;
  }

  function createAssignmentNode(lvalue, assignedExpression, assignmentOperator) {
    if (assignmentOperator.length > 1) {
      // compond assignment operator
      return generateNode("Assignment", {
          lvalue,
          expr: {
            type: "BinaryExpression",
            leftExpr: lvalue,
            rightExpr: assignedExpression,
            operator: assignmentOperator[0], // only take the first char of assignmentOperator e.g. "+" of "+="
          },
        }); 
    } else {
      return generateNode("Assignment", {
        lvalue,
        expr: assignedExpression
        }
      )
    }
  } 

  /**
   * Given an array of pointers ("*"), create a tree of PointerDeclarators, ending in the directDeclarator.
   */
  function createPointerDeclaratorNode(pointers, directDeclarator) {
    let currNode = directDeclarator;
    for (const pointer of pointers) {
      currNode = {
        type: "PointerDeclarator",
        isConst: pointer.isConst,
        directDeclarator: currNode,
      };
    }
    if (directDeclarator.functionDefinitionInfo) {
      currNode.functionDefinitionInfo = directDeclarator.functionDefinitionInfo; 
      delete directDeclarator.functionDefinitionInfo; 
    }
    return currNode;
  }

  function createFunctionDeclarator(parameterDeclarations) {
    if (typeof parameterDeclarations === "undefined") {
      return generateNode("FunctionDeclarator", {
        parameters: [],
        functionDefinitionInfo: {
          parameterNames: [],
          enumDeclarations: [],
          tagDefinitions: [],
          incompletePointers: [],
        }, // information that is only relevant to function definitions
      });
    }
    return generateNode("FunctionDeclarator", {
      parameters: parameterDeclarations.dataTypes,
      functionDefinitionInfo: {
        parameterNames: parameterDeclarations.names,
        enumDeclarations: parameterDeclarations.enumDeclarations,
        tagDefinitions: parameterDeclarations.tagDefinitions,
        incompletePointers: parameterDeclarations.incompletePointers,
      }, // information that is only relevant to function definitions
    });
  }

  // evaluate the delclarator suffixes of direct_declarator
  // this is used to evaluate declarators which have [] or () suffixes which indicate
  // that they are array or function suffixes respectively
  function evaluateDeclaratorSuffixes(directDeclarator, declaratorSuffixes) {
    let currNode = directDeclarator;
    for (const suffix of declaratorSuffixes) {
      // some error checking
      if (suffix.type === "FunctionDeclarator") {
        // you can only have string of consecutive array declarators
        if (currNode.type === "FunctionDeclarator") {
          error("Cannot have a function returning a function");
        }
        // you cannot have an array of functions
        if (currNode.type === "ArrayDeclarator") {
          error("Cannot have an array of functions");
        }
      } else {
        // suffix is "ArrayDeclarator"
        if (currNode.type === "FunctionDeclarator") {
          // cannot have a function returning array
          error("Cannot have a function returning an array");
        }
      }

      currNode = { directDeclarator: currNode, ...suffix };
    }
    return currNode;
  }

  /**
   * Unpack and process declaration specifiers
   * @returns { dataType: DataType | { type: "void" }, enumDeclarations?: { type: "EnumDeclaration", enumerators: { name: string, value?: Expression }[]}[], tagDefinition?: { name: string, dataType: DataType }, storageClass: "auto" | "static", hasTypeDefSpecifier: boolean, incompletePointers?: PointerDataType[]}
   */
  function unpackDeclarationSpecifiers(declarationSpecifiers, reportErrors = false) {
    const typeSpecifiers = [];
    let storageClass;
    let isConst = false; // only type qualifier that is supported
    let hasTypeDefSpecifier = false;

    function declarationSpecifierError(message) {
      if (reportErrors) {
        error(message)
      }
    }

    declarationSpecifiers.forEach((specifier) => {
      switch (specifier.type) {
        case "TypeSpecifier":
          typeSpecifiers.push(specifier.specifier);
          break;
        case "TypeQualifier":
          if (specifier.qualifier !== "const") {
            // should not happen
            declarationSpecifierError(`Unknown type qualifier '${specifier.qualifier}'`);
          }
          isConst = true;
          break;
        case "StorageClassSpecifier":
          if (storageClass) {
            // a storage class specifier already specified
            declarationSpecifierError(
              `multiple storage class specifiers: '${storageClass}' and '${specifier.specifier}'`
            );
          }
          if (hasTypeDefSpecifier) {
            declarationSpecifierError(`multiple storage class specifiers in declaration specifiers: 'typedef' and '${specifier.specifier}'`);
          }
          storageClass = specifier.specifier;
          break;
        case "TypeDefSpecifier":
          if (storageClass) {
            declarationSpecifierError(`multiple storage class specifiers in declaration specifiers: '${specifier.specifier}' and 'typedef'`);
          } 
          if (hasTypeDefSpecifier) {
            declarationSpecifierError("duplicate 'typedef'");
          }
          hasTypeDefSpecifier = true;
      }
    });

    if (typeSpecifiers.length < 1) {
      return { dataType: createPrimaryDataType("signed int"), noType: true, storageClass, constPresent: isConst }; // placeholder data type (other compilers would default to int, but full standard compliance means an error)
    }

    const { dataType, enumDeclarations, tagDefinitions, incompletePointers } =
      processTypeSpecifiers(typeSpecifiers);
    if (isConst) {
      dataType.isConst = true;
    }

    return {
      dataType,
      enumDeclarations,
      tagDefinitions,
      incompletePointers,
      storageClass,
      hasTypeDefSpecifier,
      constPresent: isConst // only used when processing declarations with no declarator
    };
  }

  /**
   * Processes a list of typeSpecifiers, to extract a dataType that they represent, as well as any enum variable definitions, and struct/enum type definitions
   * @returns { dataType: DataType | { type: "void" }, enumDeclarations?: { type: "EnumDeclaration" enumerators: { name: string, value?: Expression }[] }[], tagDefinitions?: { name: string, tagSymbolEntry: { type: "struct" | "enum", dataType: DataType} } }
   * dataType is the datatype indicated by the typespecifiers
   * enumDeclarations are any enum variables declared with the enum specifiers
   * tagDefinitions are any structs that are being
   */
  function processTypeSpecifiers(typeSpecifiers) {
    const firstTypeSpecifier = typeSpecifiers[0];
    if (
      firstTypeSpecifier.type === "StructTypeSpecifier" ||
      firstTypeSpecifier.type === "EnumTypeSpecifier" ||
      firstTypeSpecifier.type === "VoidTypeSpecifier" ||
      firstTypeSpecifier.type === "UserNamedTypeSpecifier"
    ) {
      if (typeSpecifiers.length > 1) {
        // cannot have any more specifiers
        error("Two or more data types in declaration specifiers");
      }
      if (firstTypeSpecifier.type === "StructTypeSpecifier") {
        const structSpecifier = firstTypeSpecifier.specifier;
        if (structSpecifier.type === "AnonymousStruct") {
          // a struct may have an enum declared within it
          return {
            dataType: structSpecifier.dataType,
            enumDeclarations: structSpecifier.enumDeclarations,
            tagDefinitions: structSpecifier.tagDefinitions,
            incompletePointers: structSpecifier.incompletePointers,
          };
        } else if (structSpecifier.type === "NamedStructDefinition") {
          // within the struct there may have been more struct/enum tags defined
          // tag has already been added within createStructSpecifier()
          return {
            dataType: structSpecifier.dataType,
            tagDefinitions: structSpecifier.tagDefinitions,
            enumDeclarations: structSpecifier.enumDeclarations,
            incompletePointers: structSpecifier.incompletePointers,
          };
        } else if (structSpecifier.type === "NamedStructReference") {
          // retrieve type from symbol table if it exists and was also a struct
          if (isTagDefined(structSpecifier.tag) && getTagSymbolEntry(structSpecifier.tag).type === "struct") {
            const symbolEntry = getTagSymbolEntry(structSpecifier.tag);
            return { dataType: symbolEntry.dataType };
          } else {
            const incompleteType = createIncompleteDataType(
                "struct",
                structSpecifier.tag
              );
            const symbolEntry = { type: "struct", dataType: incompleteType }
            const tagDefinition = addTagToSymbolTable(structSpecifier.tag, symbolEntry)
            return {
              dataType: incompleteType,
              tagDefinitions: [
                tagDefinition
              ],
            }; // incomplete type for now, to be resolved later when struct is defined
          }
        }
      } else if (firstTypeSpecifier.type === "EnumTypeSpecifier") {
        const enumSpecifier = firstTypeSpecifier.specifier;
        if (enumSpecifier.type === "NamedDefinedEnum") {
          // a new enum has been defined
          const newTagSymbolEntry = {
            type: "enum",
            dataType: createEnumDataType(enumSpecifier.tag),
          };
          addTagToSymbolTable(enumSpecifier.tag, newTagSymbolEntry);
          enumSpecifier.enumerators.forEach((enumerator) => {
            addIdentifierToSymbolTable(enumerator.name, {
              type: "variable",
              dataType: createEnumDataType(enumSpecifier.tag),
            });
          });
          return {
            dataType: createEnumDataType(enumSpecifier.tag),
            enumDeclarations: [
              { type: "EnumDeclaration", enumerators: enumSpecifier.enumerators },
            ],
            tagDefinitions: [
              { name: enumSpecifier.tag, symbolEntry: newTagSymbolEntry },
            ],
          }; // all enums defined as having signed int type
        } else if (enumSpecifier.type === "AnonymousEnum") {
          enumSpecifier.enumerators.forEach((enumerator) => {
            addIdentifierToSymbolTable(enumerator.name, {
              type: "variable",
              dataType: createEnumDataType(enumSpecifier.tag),
            });
          });
          return {
            dataType: createEnumDataType(null),
            enumDeclarations: [
              { type: "EnumDeclaration", enumerators: enumSpecifier.enumerators },
            ],
          };
        } else if (enumSpecifier.type === "NamedEnumReference") {
          if (isTagDefined(enumSpecifier.tag) && getTagSymbolEntry(enumSpecifier.tag).type === "enum") {
            const symbolEntry = getTagSymbolEntry(enumSpecifier.tag);
            return { dataType: symbolEntry.dataType };
          } else {
            const incompleteType = createIncompleteDataType(
                "enum",
                enumSpecifier.tag
              );
            const symbolEntry = { type: "enum", dataType: incompleteType }
            const tagDefinition = addTagToSymbolTable(enumSpecifier.tag, symbolEntry)
            return { dataType: incompleteType, tagDefinitions: [ tagDefinition ] };
          }
        }
      } else if (firstTypeSpecifier.type === "VoidTypeSpecifier") {
        return { dataType: { type: "void" } };
      } else if (firstTypeSpecifier.type === "UserNamedTypeSpecifier") {
        if (!isIdentifierAType(firstTypeSpecifier.typeName)) {
          error(`undeclared type '${firstTypeSpecifier.typeName}'`);
        }
        return {
          dataType: getIdentifierSymbolEntry(firstTypeSpecifier.typeName)
            .dataType,
        };
      }
    } else if (firstTypeSpecifier.type === "UnknownTypeSpecifier") {
      throwErrorWithLocation(`unknown type name '${firstTypeSpecifier.typeName}'`);
    } else {
      // only dealing with primary data types now
      let lengthSpecifier;
      let intSignSpecifier;
      let primaryDataTypeSpecifier;
      for (const specifier of typeSpecifiers) {
        if (specifier.type === "PrimaryTypeSpecifier") {
          if (primaryDataTypeSpecifier) {
            // error if primary data type already given
            error("Two or more data types in declaration specifiers");
          }
          primaryDataTypeSpecifier = specifier.specifier;
        } else if (specifier.type === "PrimaryDataTypeLengthSpecifier") {
          if (lengthSpecifier) {
            error(
              `Both '${lengthSpecifier}' and '${specifier.specifier}' in declaration specifiers`
            );
          }
          lengthSpecifier = specifier.specifier;
        } else if (specifier.type === "IntegerSignSpecifier") {
          if (intSignSpecifier) {
            error(
              `Both '${intSignSpecifier}' and '${specifier.specifier}' in declaration specifiers`
            );
          }
          intSignSpecifier = specifier.specifier;
        }
      }

      if (!primaryDataTypeSpecifier && !lengthSpecifier && !intSpecifier) {
        error("type specifier required in declaration specifiers");
      }

      if (
        primaryDataTypeSpecifier === "float" ||
        primaryDataTypeSpecifier === "double"
      ) {
        if (intSignSpecifier) {
          error(
            `Both '${intSignSpecifier}' and '${primaryDataTypeSpecifier}' in declaration specifiers`
          );
        }
        return { dataType: createPrimaryDataType(primaryDataTypeSpecifier) };
      } else if (primaryDataTypeSpecifier === "char") {
        const intSignPrefix = intSignSpecifier ? intSignSpecifier + " " : "signed "; // integral types are signed by default
        if (lengthSpecifier) {
          error(
            `Both '${lengthSpecifier}' and '${primaryDataTypeSpecifier}' in declaration specifiers`
          );
        }
        return { dataType: createPrimaryDataType(intSignPrefix + "char") };
      } else {
        // default primary data type is int
        const intSignPrefix = intSignSpecifier ? intSignSpecifier + " " : "signed "; // integral types are signed by default
        if (lengthSpecifier) {
          return {
            dataType: createPrimaryDataType(intSignPrefix + lengthSpecifier),
          };
        } else {
          // just int
          return { dataType: createPrimaryDataType(intSignPrefix + "int") };
        }
      }
    }
  }

  // Unpacks a series of { declarations: Declaration, incompletePointers: PointerDataType } objects into
  // one singular object { declarations: Declaration, incompletePointers: PointerDataType }
  function unpackDeclarations(declarations) {
    const unpackedResult = {
      declarations: [],
      incompletePointers: [],
    };

    declarations.forEach(({ declarations, incompletePointers }) => {
      unpackedResult.declarations.push(...declarations);
      unpackedResult.incompletePointers.push(...incompletePointers);
    });
    return unpackedResult;
  }

  // Similar to unpackDeclarations, with enumDeclarations and tagDefinitions also being unpacked
  function unpackStructDeclarations(declarations) {
    const unpackedResult = {
      declarations: [],
      incompletePointers: [],
      enumDeclarations: [], // all the enum variables declarad within the struct
      tagDefinitions: [], // all the structs/enums declared within the struct
    };

    declarations.forEach(
      ({
        declarations,
        incompletePointers,
        enumDeclarations,
        tagDefinitions,
      }) => {
        unpackedResult.declarations.push(...declarations);
        if (incompletePointers) {
          unpackedResult.incompletePointers.push(...incompletePointers);
        }
        if (enumDeclarations) {
          unpackedResult.enumDeclarations.push(...enumDeclarations);
        }
        if (tagDefinitions) {
          unpackedResult.tagDefinitions.push(...tagDefinitions);
        }
      }
    );
    return unpackedResult;
  }

  /**
   * Called after a new struct is declared.
   * @returns { dataType: StructDataType, incompletePointers: PointerDataType[], enumDeclarations: { type: "EnumeratorDeclaration", enumerators: { name: string, value: number}[]}[], tagDefinitions }
   * 
   */
  function createStructSpecifier(unpackedFieldDeclarations, tag) {
    const structDataType = {
      type: "struct",
      tag,
      fields: [],
    };

    // add the declarations of each field to the struct
    if (unpackedFieldDeclarations.declarations) {
      unpackedFieldDeclarations.declarations.forEach((declaration) => {
        structDataType.fields.push({
          tag: declaration.name,
          dataType: declaration.dataType,
        });
      });
    }

    // resolve all incomplete pointers which can be resolved
    const incompletePointers = [];
    unpackedFieldDeclarations.incompletePointers.forEach((incompletePointer) => {
      const pointeeTag = incompletePointer.pointeeType.tag;
      const tagType = incompletePointer.pointeeType.subtype;
      if (pointeeTag === tag) {
        // this is a pointer that points to the struct it is within
        if (tagType !== "struct") {
          error(`'${pointeeTag}' declared as wrong kind of tag`);
        }
        delete incompletePointer.pointeeType;
        incompletePointer.type = "struct self pointer";
      } else {
        if (isTagDefined(pointeeTag)) {
          const symbolEntry = getTagSymbolEntry(pointeeTag);
          if (symbolEntry.type !== tagType) {
            error(`'${pointeeTag}' declared as wrong kind of tag`);
          }
          // incomplete pointer is now complete (pointing to complete type)
          incompletePointer.pointeeType = symbolEntry.dataType;
        } else {
          // still incomplete
          incompletePointers.push(incompletePointer.pointeeType);
        }
      }
    });

    // add this new struct (if named) thats been declared to the tagDefinitions & symboltable
    const tagDefinitions = unpackedFieldDeclarations.tagDefinitions ?? [];
    if (tag) {
      const symbolEntry = { type: "struct", dataType: structDataType };
      const tagDefinition = addTagToSymbolTable(tag, symbolEntry);
      tagDefinitions.push(tagDefinition);
    }

    return {
      dataType: structDataType,
      incompletePointers,
      enumDeclarations: unpackedFieldDeclarations.enumDeclarations,
      tagDefinitions,
    };
  }

  function createEmptyStructSpecifier(tag) {
    error("struct has no members");
    return {
      dataType: {
        type: "struct",
        tag,
        fields: [], 
      },
      incompletePointers: [],
      enumDeclarations: [],
      tagDefinitions: [],
    }; 
  }

  // Recursively traverses a tree of declarators to create a DataType object and extract the name of the symbol with this dataType,
  // returning the object with type: { name: string, dataType: DataType, incompletePointer?: PointerDataType }
  // this function is able to evaluate declarators used in function declarations that do not have a symbol as well.
  // optionally takes a param @isFunctionParam that indicates that this declarator is used in a function parameter
  function convertDeclaratorIntoDataTypeAndSymbolName(
    declarator,
    typeSpecifierDataType,
    isFunctionParam
  ) {
    const result = { functionDefinitionInfo: declarator.functionDefinitionInfo };
    let currNode = result;
    // helper function to add datatype to currNode
    function addDataType(dataTypeToAdd) {
      // only pointers and functions can have null type specifier - void type
      if (dataTypeToAdd.type === "void") {
        if (typeof currNode.type === "undefined" || currNode.type === "primary") {
          error(`Variable or field declared as void`);
        } else if (currNode.type === "array") {
          error(`Declaration of array of void type`);
        } 
      }
      if (currNode.type === "array") {
        currNode.elementDataType = dataTypeToAdd;
      } else if (currNode.type === "pointer") {
        currNode.pointeeType = dataTypeToAdd;
      } else if (currNode.type === "function") {
        currNode.returnType = dataTypeToAdd;
      } else {
        currNode.dataType = dataTypeToAdd;
      }
    }

    function recursiveHelper(declarator) {
      if (declarator.type === "SymbolDeclarator") {
        // all non-abstract declarations will end with a symbol (based on parsing rules)
        result.name = declarator.symbolName;
        return;
      } else if (declarator.type === "AbstractDeclarator") {
        // recursive tail of symboless declaration that can only be used in function declarations
        result.name = null;
        return;
      } else {
        // all other declarators require more traversal
        recursiveHelper(declarator.directDeclarator);
      }

      if (declarator.type === "PointerDeclarator") {
        const pointerType = {
          type: "pointer",
          isConst: declarator.isConst,
        };
        addDataType(pointerType);
        currNode = pointerType;
      } else if (declarator.type === "FunctionDeclarator") {
        const functionType = {
          type: "function",
          parameters: declarator.parameters,
          parameterNames: declarator.parameterNames,
        };
        // some error checks
        if (currNode.type === "FunctionDeclarator") {
          error("Cannot declare a function returning a function");
        } else if (currNode.type === "ArrayDeclarator") {
          error("Cannot declare an array of functions");
        }

        addDataType(functionType);
        currNode = functionType;
      } else if (declarator.type === "ArrayDeclarator") {
        const arrayType = {
          type: "array",
          numElements: declarator.numElements,
        };

        if (currNode.type === "FunctionDeclarator") {
          error("Cannot declare a function returning an array");
        }

        addDataType(arrayType);
        currNode = arrayType;
      } else {
        error("Unknown declarator type");
      }
    }

    recursiveHelper(declarator);

    // Only pointers can point to incomplete types
    if (typeSpecifierDataType.type === "incomplete") {
      if (currNode.type !== "pointer") {
        error(`'${typeSpecifierDataType.tag}' is an incomplete type`);
      } else {
        // keep track that this pointer datatype as incomplete
        result.incompletePointer = currNode;
      }
    }

    addDataType(typeSpecifierDataType);

    if (isFunctionParam && result.dataType.type === "array") {
      // function parameters that are arrays are implictly converted into pointers to the underlying array element type
      result.dataType = {
        type: "pointer",
        pointeeType: result.dataType.elementDataType,
      };
    }

    return result;
  }

  /**
   * Creates intiializer list from string literal.
   * @param chars array of characters in the string, already in numeric form
   */
  function generateInitializerListFromStringLiteral(chars) {
    return generateNode("InitializerList", {
      values: chars.map((char) => ({
        type: "InitializerSingle",
        value: {
          type: "IntegerConstant",
          value: BigInt(char),
          suffix: null,
        },
      })),
    });
  }

  /**
   * Removes all the identifiers and tags(structs/enums) that were introduced to the symboltable inside parameter declarations of a function.
   */
  function removeFunctionParamIdentifiersAndTags(
    tagDefinitions,
    enumDeclarations,
    parameterNames
  ) {
    // remove all struct/enum tags
    const removedTags = new Set();
    for (const tagDefinition of tagDefinitions) {
      if (removedTags.has(tagDefinition.name)) {
        error(`redefinition of '${tagDefinition.tagSymbolEntry.type} ${tagDefinition.name}'`);
      }
      removedTags.add(tagDefinition.name);
      removeTagSymbolEntry(tagDefinition.name);
    }

    const removedIdentifiers = new Set();
    // remove all enumerator identifiers defined in params
    for (const enumDeclaration of enumDeclarations) {
      enumDeclaration.enumerators.forEach((e) => {
        if (removedIdentifiers.has(e.name)) {
          error(`'${e.name}' redeclared as different kind of symbol`)
        }
        removedIdentifiers.add(e.name);
        removeIdentifierSymbolEntry(e.name);
      });
    }
    

    // remove all parameter identifiers, no need check for redefintion as it was done in unpackParameters() already
    for (const paramName of parameterNames) {
      if (paramName !== null) {
        removeIdentifierSymbolEntry(paramName);
      }
    }
  }

  /**
   * Processes declarations.
   * Returns the declarations, as well as the dataType objects that are pointers to incomplete types
   * @returns { type: "Declaration", declarations: Declaration[], incompletePointers: PointerDataType[], tagDefinitions: { name: string, symbolEntry: { type: "struct" | "enum", dataType: DataType } }[], identifierDefinitions: { name: string, symbolEntry: { type: "type" | "variable", dataType: DataType } }[] }
   * identifierDefinitions is { name: string, symbolEntry: SymbolEntry } that represents each declared identifier
   * tagDefinitions is { name: string, symbolEntry: SymbolEntry } that represents each declared tag
   */
  function processDeclaration(declarationSpecifiers, declarators) {
    const declarations = [];
    const identifierDefinitions = [];
    const {
      enumDeclarations,
      tagDefinitions,
      hasTypeDefSpecifier,
      incompletePointers: incompletePointersFromSpecifiers,
      noType
    } = unpackDeclarationSpecifiers(declarationSpecifiers, true);

    if (noType) {
      error("at least 1 type specifier required in declaration specifiers of declaration");
    }

    const incompletePointers = incompletePointersFromSpecifiers ?? [];
    // add all enum fields as enum declarations to the array of all declarations
    if (typeof enumDeclarations !== "undefined") {
      enumDeclarations.forEach((enumDeclaration) => {
        declarations.push(enumDeclaration);
        // enumerator identifiers were already added to the symboltable, just track their identifier definitions
        for (const enumerator of enumDeclaration.enumerators) {
          identifierDefinitions.push({
            name: enumerator.name,
            symbolEntry: getIdentifierSymbolEntry(enumerator.name),
          });
        }
      });
    }
    declarators.forEach((declarator) => {
      const { declaration, incompletePointer } = evaluateDeclarator(
        declarationSpecifiers,
        declarator
      );
      // actually a typedef declaration
      if (hasTypeDefSpecifier) {
        if (declaration.initializer) {
          error("typedef is initialized");
        }
        identifierDefinitions.push(
          addIdentifierToSymbolTable(declaration.name, {
            type: "type",
            dataType: declaration.dataType,
          })
        );
      } else {
        identifierDefinitions.push(
          addIdentifierToSymbolTable(declaration.name, {
            type: "variable",
            dataType: declaration.dataType,
          })
        );
        declarations.push(declaration);
        // remove all tags and identifiers that were introduced in the parameters if this were a function declaration
        if (declarator.functionDefinitionInfo) {
          removeFunctionParamIdentifiersAndTags(
            declarator.functionDefinitionInfo.tagDefinitions,
            declarator.functionDefinitionInfo.enumDeclarations,
            declarator.functionDefinitionInfo.parameterNames
          );
          // delete this functionDefinition field from declarator - it is not needed
          delete declarator.functionDefinitionInfo;
        }
      }

      if (incompletePointer) {
        incompletePointers.push(incompletePointer);
      }
    });

    return generateNode("Declaration", {
      declarations,
      incompletePointers,
      identifierDefinitions,
      tagDefinitions,
    });
  }

  // similar to processDeclarations, with added enumeratorDeclaration as a result field (no longer incorporated into declarations)
  function processStructDeclaration(declarationSpecifiers, declarators) {
    const declarations = [];
    const incompletePointers = [];
    const {
      enumDeclarations,
      tagDefinitions,
      storageClass,
      hasTypeDefSpecifier,
    } = unpackDeclarationSpecifiers(declarationSpecifiers, true);
    if (storageClass || hasTypeDefSpecifier) {
      error("Struct field cannot have storage class specifier");
    }

    declarators.forEach((declarator) => {
      const { declaration, incompletePointer } = evaluateDeclarator(
        declarationSpecifiers,
        declarator
      );
      declarations.push(declaration);
      if (incompletePointer) {
        incompletePointers.push(incompletePointer);
      }
    });

    return { declarations, incompletePointers, enumDeclarations, tagDefinitions };
  }

  // evaluates the return of init_declarator or declarator with the given array of declaration specifiers, to return a declaration
  // return type: { declaration: Declaration, incompletePointer?: PointerDataType }
  function evaluateDeclarator(declarationSpecifiers, declarator) {
    const { dataType: typeSpecifierDataType, storageClass } =
      unpackDeclarationSpecifiers(declarationSpecifiers);
    const { name, dataType, incompletePointer, functionDefinitionInfo } =
      convertDeclaratorIntoDataTypeAndSymbolName(
        declarator,
        typeSpecifierDataType
      );

    const declarationNode = generateNode("Declaration", {
      name: name,
      storageClass: storageClass ?? "auto", // storage class is auto by default
      dataType: dataType,
      initializer: declarator.initializer, // may be undefined
    });
    if (declarationNode.dataType.type === "array") {
      if (typeof declarationNode.initializer !== "undefined") {
        if (declarationNode.initializer.type !== "InitializerList") {
          if (declarationNode.initializer.value.type === "StringLiteral") {
            declarationNode.initializer =
              generateInitializerListFromStringLiteral(
                declarationNode.initializer.value.chars
              );
          } else {
            error("Invalid initializer for array");
          }
        }
        // Array size deduction based on initializer list size
        if (typeof declarationNode.dataType.numElements === "undefined") {
          declarationNode.dataType.numElements = generateNode("IntegerConstant", {
            value: BigInt(declarationNode.initializer.values.length),
          });
        }
      } else if (typeof declarationNode.dataType.numElements === "undefined") {
        // no intializer provided, if numElements not defined, then it is set to 1 - TODO: provide warning to user
        declarationNode.dataType.numElements = generateNode("IntegerConstant", {
          value: 1n,
        });
      }
    }

    return {
      declaration: declarationNode,
      incompletePointer,
      functionDefinitionInfo,
    };
  }

  // Process function parameter.
  // @returns { type: "ParameterDeclaration", name: string | null, dataType: DataType, enumDeclarations, tagDefinitions, incompletePointers }
  function processParameterDeclaration(declarationSpecifiers, declarator) {
    const {
      dataType: typeSpecifierDataType,
      enumDeclarations,
      tagDefinitions,
      incompletePointers,
      storageClass,
      hasTypeDefSpecifier,
      noType
    } = unpackDeclarationSpecifiers(declarationSpecifiers, true);

    if (noType) {
      error("at least 1 type specifier required in declaration specifiers of declaration");
    }

    if (storageClass || hasTypeDefSpecifier) {
      error(`Cannot specify storage class for function parameter`);
    }
    if (declarator === null) {
      // abstractDeclarator was null
      return generateNode("ParameterDeclaration", {
        name: null,
        dataType: typeSpecifierDataType,
        enumDeclarations,
        tagDefinitions,
        incompletePointers,
      });
    }
    const { name, dataType, incompletePointer } =
      convertDeclaratorIntoDataTypeAndSymbolName(
        declarator,
        typeSpecifierDataType,
        true
      );

    if (incompletePointer) {
      incompletePointers.push(incompletePointer);
    }

    // add this parameter to symbol table
    addIdentifierToSymbolTable(name, {
      type: "variable",
      dataType: dataType,
    });

    if (enumDeclarations) {
      for (const enumDeclaration of enumDeclarations) {
        // add any declared enum variables
        enumDeclaration.enumerator.forEach((enumerator) => {
          addIdentifierToSymbolTable(enumerator.name, {
            type: "variable",
            dataType: createPrimaryDataType("signed int"),
          });
        });
      }
    }

    return generateNode("ParameterDeclaration", {
      name,
      dataType,
      enumDeclarations,
      tagDefinitions,
      incompletePointers,
    });
  }

  /**
   * Used to generate the DataType for type_name rule.
   * Functionally very similar to convertParameterDeclarationToDataTypeAndSymbolName.
   */
  function generateDataTypeFromSpecifierAndAbstractDeclarators(
    declarationSpecifiers,
    declarator
  ) {
    const { dataType: typeSpecifierDataType } = unpackDeclarationSpecifiers(
      declarationSpecifiers
    );
    if (declarator === null) {
      // abstractDeclarator was null
      return typeSpecifierDataType;
    }
    return convertDeclaratorIntoDataTypeAndSymbolName(
      declarator,
      typeSpecifierDataType
    ).dataType;
  }

  // extracts out all the datatype, names, enumDeclarations, tagDefinitions and incompletePointers from a set of parameterDeclarations
  function unpackParameters(parameterDeclarations) {
    const dataTypes = [];
    const names = [];
    const enumDeclarations = [];
    const tagDefinitions = [];
    const incompletePointers = [];
    const setOfIdentifiers = new Set();
    const setOfTags = new Set(); 
    parameterDeclarations.forEach((paramDeclaration) => {
      if (paramDeclaration.name !== null && setOfIdentifiers.has(paramDeclaration.name)) {
        error(`redefinition of parameter '${paramDeclaration.name}'`)
      }
      dataTypes.push(paramDeclaration.dataType);
      names.push(paramDeclaration.name);
      setOfIdentifiers.add(paramDeclaration.name);
      if (paramDeclaration.enumDeclarations) {
        enumDeclarations.forEach(enumDeclaration => {
          enumDeclaration.enumerators.forEach(enumerator => {
            if (setOfIdentifiers.has(enumerator.name)) {
              error(`'${enumerator.name}' redeclared as different kind of symbol`) 
            }
            setOfIdentifiers.add(enumerator.name);
          });
        });
        enumDeclarations.push(...paramDeclaration.enumDeclarations);
      }
      if (paramDeclaration.tagDefinitions) {
        tagDefinitions.forEach(tagDefinition => {
          if (setOfTags.has(tagDefinition.name)) {
            error(`redefinition of '${tagDefinition.tagSymbolEntry.type} ${tagDefinition.name}'`);
          } 
        });
        tagDefinitions.push(...paramDeclaration.tagDefinitions);
      }
      if (paramDeclaration.incompletePointers) {
        incompletePointers.push(...paramDeclaration.incompletePointers);
      }
    });

    return {
      names,
      dataTypes,
      enumDeclarations,
      tagDefinitions,
      incompletePointers,
    };
  }

  function generateFunctionDefinitionNode(
    declarationSpecifiers,
    declarator,
    body
  ) {
    const { declaration, functionDefinitionInfo } = evaluateDeclarator(
      declarationSpecifiers,
      declarator
    );
    const dataType = declaration.dataType;
    const name = declaration.name;
    if (!functionDefinitionInfo || dataType.type !== "function") {
      error("compound statement can only follow a function declarator");
    }

    addIdentifierToSymbolTable(declaration.name, {type: "variable", dataType});  

    const incompletePointers = body.incompletePointers;
    delete body.incompletePointers;

    // remove all tagDefinitions and identifiers declared in params from symboltable
    removeFunctionParamIdentifiersAndTags(
      functionDefinitionInfo.tagDefinitions,
      functionDefinitionInfo.enumDeclarations,
      functionDefinitionInfo.parameterNames
    );

    return generateNode("FunctionDefinition", {
      type: "FunctionDefinition",
      name: name,
      dataType: dataType,
      body,
      parameterNames: functionDefinitionInfo.parameterNames,
      incompletePointers
    });
  }

  /**
   * Used to create a ForLoop node whose clause is a declaration.
   */
  function createDeclarationForLoopNode(declaration, condition, update, body) {
    const { declarations, incompletePointers, identifierDefinitions, tagDefinitions } = declaration;
    // tagDefinitions not allowed in for loop
    if (tagDefinitions) {
      for (const tagDefinition of tagDefinitions) {
        error(`'${tagDefinition.tagSymbolEntry.type} ${tagDefinition.name}' declared in 'for' loop initialization`)
      }
    }
    // no need to handle incmplete pointers since there is no possibility of declaring them in a tag 

    // checks on declarations
    for (const declaration of declarations) {
      if (declaration.type === "EnumDeclaration") {
        // enum declarations not allowed in for loop clause
        for (const enumerator of declaration.enumerators) {
          error(`Declaration of non-variable '${enumerator.name}' in for loop initial declaration`);
        }
      } else if (declaration.storageClass !== "auto" && declaration.storageClass !== "register") { // as per standard, for loop variable can only be "auto" or "register" 
        error(`Declaration of ${declaration.storageClass} variable '${declaration.name}' in for loop initial declaration`);
      }
    }

    // remove all identifiers that were declared in for loop clause
    const removedIdentifiers = new Set();
    for (const identifierDefinition of identifierDefinitions) {
      if (identifierDefinition.name !== null) {
        if (removedIdentifiers.has(identifierDefinition.name)) {
          error(`redeclaration of variable ${identifierDefinition.name}`)
        }
        removedIdentifiers.add(identifierDefinition.name);
        removeIdentifierSymbolEntry(identifierDefinition.name);
      }
    }

    return generateNode("ForLoop", { clause: { type: "Declaration", value: declarations }, condition, update, body });
  }

  function addIncludedModuleDefinitions(includedModuleName) {
    addIncludedModuleFunctionDefinitions(includedModuleName);
    addIncludedModuleStructDefinitions(includedModuleName); 
  }
  
  function addIncludedModuleFunctionDefinitions(includedModuleName) {
   if (!(includedModuleName in thisParser.moduleRepository.modules)) {
      // included module is not found
      error(`Included module "${includedModuleName}" does not exist`);
    }

    // add all the defined structs in the module
    Object.entries(thisParser.moduleRepository.modules[includedModuleName].moduleFunctions).forEach(([name, fnDataType]) => {
      addIdentifierToSymbolTable(name, {type: "variable", dataType: fnDataType});
    }) 
  }

  function addIncludedModuleStructDefinitions(includedModuleName) {
    if (!(includedModuleName in thisParser.moduleRepository.modules)) {
      // included module is not found
      error(`Included module "${includedModuleName}" does not exist`);
    }

    // add all the defined structs in the module
    thisParser.moduleRepository.modules[includedModuleName].moduleDeclaredStructs.forEach(s => {
      addTagToSymbolTable(s.tag, {type: "struct", dataType: s});
    })
  }

  function createSizeOfDataTypeExpression(dataType) {
    if (dataType.type === "incomplete") {
      error("invalid application of 'sizeof' to incomplete type");
    }
    return generateNode("SizeOfExpression", { subtype: "dataType", dataType });
  }


  peg$result = peg$startRuleFunction();

  if (options.peg$library) {
    return /** @type {any} */ ({
      peg$result,
      peg$currPos,
      peg$FAILED,
      peg$maxFailExpected,
      peg$maxFailPos
    });
  }
  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  StartRules: ["program"],
  SyntaxError: peg$SyntaxError,
  parse: peg$parse
};
